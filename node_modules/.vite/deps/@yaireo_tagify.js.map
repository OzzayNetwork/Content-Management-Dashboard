{
  "version": 3,
  "sources": ["../../@yaireo/tagify/dist/src/parts/constants.js", "../../@yaireo/tagify/dist/src/parts/helpers.js", "../../@yaireo/tagify/dist/src/parts/defaults.js", "../../@yaireo/tagify/dist/src/parts/dropdown.js", "../../@yaireo/tagify/dist/src/parts/suggestions.js", "../../@yaireo/tagify/dist/src/parts/persist.js", "../../@yaireo/tagify/dist/src/parts/texts.js", "../../@yaireo/tagify/dist/src/parts/templates.js", "../../@yaireo/tagify/dist/src/parts/events.js", "../../@yaireo/tagify/dist/src/tagify.js", "../../@yaireo/tagify/dist/src/parts/EventDispatcher.js"],
  "sourcesContent": ["export var ZERO_WIDTH_CHAR = '\\u200B';\nexport var ZERO_WIDTH_UNICODE_CHAR = `&#8203;`\nexport const UPDATE_DELAY = 100\n", "import {ZERO_WIDTH_CHAR} from './constants'\n\nexport const logger = {\n    isEnabled() { return window.TAGIFY_DEBUG ?? true},\n    log(...args){ this.isEnabled() && console.log('[Tagify]:', ...args) },\n    warn(...args) { this.isEnabled() && console.warn('[Tagify]:', ...args) }\n}\n\n// console.json = console.json || function(argument){\n//     for(var arg=0; arg < arguments.length; ++arg)\n//         console.log(  JSON.stringify(arguments[arg], null, 4)  )\n// }\n\n// const isEdge = /Edge/.test(navigator.userAgent)\nexport const sameStr = (s1, s2, caseSensitive, trim) => {\n    // cast to String\n    s1 = \"\"+s1;\n    s2 = \"\"+s2;\n\n    if( trim ){\n        s1 = s1.trim()\n        s2 = s2.trim()\n    }\n\n    return caseSensitive\n        ? s1 == s2\n        : s1.toLowerCase() == s2.toLowerCase()\n}\n\n\n// const getUID = () => (new Date().getTime() + Math.floor((Math.random()*10000)+1)).toString(16)\nexport const removeCollectionProp = (collection, unwantedProps) => collection && Array.isArray(collection) && collection.map(v => omit(v, unwantedProps))\n\nexport function omit(obj, props){\n    var newObj = {}, p;\n    for( p in obj )\n        if( props.indexOf(p) < 0 )\n            newObj[p] = obj[p]\n    return newObj\n}\n\nexport function decode( s ) {\n    var el = document.createElement('div');\n    return s.replace(/\\&#?[0-9a-z]+;/gi, function(enc){\n        el.innerHTML = enc;\n        return el.innerText\n    })\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/35385518/104380\n * @param  {String} s [HTML string]\n * @return {Object}   [DOM node]\n */\nexport function parseHTML( s ){\n    var parser = new DOMParser(),\n        node   = parser.parseFromString(s.trim(), \"text/html\");\n\n    return node.body.firstElementChild;\n}\n\n/**\n * Removed new lines and irrelevant spaces which might affect layout, and are better gone\n * @param {string} s [HTML string]\n */\nexport function minify( s ){\n    return s ? s\n        .replace(/\\>[\\r\\n ]+\\</g, \"><\")\n        .split(/>\\s+</).join('><').trim()\n        : \"\"\n}\n\nexport function removeTextChildNodes( elm ){\n    var iter = document.createNodeIterator(elm, NodeFilter.SHOW_TEXT, null, false),\n        textnode;\n\n    // print all text nodes\n    while (textnode = iter.nextNode()){\n        if( !textnode.textContent.trim() )\n            textnode.parentNode.removeChild(textnode)\n    }\n}\n\nexport function getfirstTextNode( elm, action ){\n    action = action || 'previous';\n    while ( elm = elm[action + 'Sibling'] )\n        if( elm.nodeType == 3 )\n            return elm\n}\n\n/**\n * utility method\n * https://stackoverflow.com/a/6234804/104380\n */\nexport function escapeHTML( s ){\n    return typeof s == 'string' ? s\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/`|'/g, \"&#039;\")\n        : s;\n}\n\n/**\n * Checks if an argument is a javascript Object\n */\nexport function isObject(obj) {\n    var type = Object.prototype.toString.call(obj).split(' ')[1].slice(0, -1);\n    return obj === Object(obj) && type != 'Array' && type != 'Function' && type != 'RegExp' && type != 'HTMLUnknownElement';\n}\n\n/**\n * merge objects into a single new one\n * TEST: extend({}, {a:{foo:1}, b:[]}, {a:{bar:2}, b:[1], c:()=>{}})\n */\nexport function extend( o, o1, o2) {\n    if( !(o instanceof Object) ) o = {};\n\n    copy(o, o1);\n    if( o2 )\n        copy(o, o2)\n\n    function copy(a,b){\n        // copy o2 to o\n        for( var key in b )\n            if( b.hasOwnProperty(key) ){\n                if( isObject(b[key]) ){\n                    if( !isObject(a[key]) )\n                        a[key] = Object.assign({}, b[key])\n                    else\n                        copy(a[key], b[key])\n\n                    continue;\n                }\n\n                if( Array.isArray(b[key]) ){\n                    a[key] = Object.assign([], b[key])\n                    continue\n                }\n\n                a[key] = b[key]\n            }\n    }\n\n    return o\n}\n\n/**\n * concatenates N arrays without dups.\n * If an array's item is an Object, compare by `value`\n */\nexport function concatWithoutDups(){\n    const newArr = [],\n        existingObj = {};\n\n    for( let arr of arguments ) {\n        for( let item of arr ) {\n            // if current item is an object which has yet to be added to the new array\n            if( isObject(item) ){\n                if( !existingObj[item.value] ){\n                    newArr.push(item)\n                    existingObj[item.value] = 1\n                }\n            }\n\n            // if current item is not an object and is not in the new array\n            else if( !newArr.includes(item) )\n                newArr.push(item)\n        }\n    }\n\n    return newArr\n}\n\n/**\n *  Extracted from: https://stackoverflow.com/a/37511463/104380\n * @param {String} s\n */\nexport function unaccent( s ){\n    // if not supported, do not continue.\n    // developers should use a polyfill:\n    // https://github.com/walling/unorm\n    if( !String.prototype.normalize )\n        return s\n\n    if (typeof(s) === 'string')\n        return s.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\n/**\n * Meassures an element's height, which might yet have been added DOM\n * https://stackoverflow.com/q/5944038/104380\n * @param {DOM} node\n */\nexport function getNodeHeight( node ){\n    var height, clone = node.cloneNode(true)\n    clone.style.cssText = \"position:fixed; top:-9999px; opacity:0\"\n    document.body.appendChild(clone)\n    height = clone.clientHeight\n    clone.parentNode.removeChild(clone)\n    return height\n}\n\nexport var isChromeAndroidBrowser = () => /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent)\n\nexport function getUID() {\n    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>\n        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n    )\n}\n\nexport function isNodeTag(node){\n    const belongs = isNodeBelongsToThisTagifyInstance.call(this, node);\n    const isTag = node?.classList?.contains(this.settings.classNames.tag)\n    return belongs && isTag\n}\n\nexport function isWithinNodeTag(node){\n    return isNodeBelongsToThisTagifyInstance.call(this, node) && node?.closest(this.settings.classNames.tagSelector)\n}\n\nfunction isNodeBelongsToThisTagifyInstance(node) {\n    let closestTagifyNode = node?.closest?.(this.settings.classNames.namespaceSelector)\n    return closestTagifyNode === this.DOM.scope\n}\n\n/**\n* Get the caret position relative to the viewport\n* https://stackoverflow.com/q/58985076/104380\n*\n* @returns {object} left, top distance in pixels\n*/\nexport function getCaretGlobalPosition(){\n   const sel = document.getSelection()\n\n   if( sel.rangeCount ){\n       const r = sel.getRangeAt(0)\n       const node = r.startContainer\n       const offset = r.startOffset\n       let rect,  r2;\n\n       if (offset > 0) {\n           r2 = document.createRange()\n           r2.setStart(node, offset - 1)\n           r2.setEnd(node, offset)\n           rect = r2.getBoundingClientRect()\n           return {left:rect.right, top:rect.top, bottom:rect.bottom}\n       }\n\n       if( node.getBoundingClientRect )\n           return node.getBoundingClientRect()\n   }\n\n   return {left:-9999, top:-9999}\n}\n\n/**\n * Injects content (either string or node) at the current the current (or specificed) caret position\n * @param {content} string/node\n * @param {range} Object (optional, a range other than the current window selection)\n */\nexport function injectAtCaret(content, range){\n    var selection = window.getSelection();\n    range = range || selection.getRangeAt(0)\n\n    if( typeof content == 'string' )\n        content = document.createTextNode(content)\n\n    if( range ) {\n        range.deleteContents()\n        range.insertNode(content)\n    }\n\n    return content\n}\n\n/** Setter/Getter\n * Each tag DOM node contains a custom property called \"__tagifyTagData\" which hosts its data\n * @param {Node}   tagElm\n * @param {Object} data\n */\nexport function getSetTagData(tagElm, data, override){\n    if( !tagElm ){\n        logger.warn(\"tag element doesn't exist\",{tagElm, data})\n        return data\n    }\n\n    if( data )\n        tagElm.__tagifyTagData = override\n            ? data\n            : extend({}, tagElm.__tagifyTagData || {}, data)\n\n    return tagElm.__tagifyTagData\n}\n\nexport function placeCaretAfterNode( node ){\n    if( !node || !node.parentNode ) return\n\n    var nextSibling = node,\n        sel = window.getSelection(),\n        range = sel.getRangeAt(0);\n\n    if (sel.rangeCount) {\n        range.setStartAfter(nextSibling);\n        range.collapse(true)\n        // range.setEndBefore(nextSibling || node);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n}\n\n/**\n * iterate all tags, checking if multiple ones are close-siblings and if so, add a zero-space width character between them,\n * which forces the caret to be rendered when the selection is between tags.\n * Also do that if the tag is the first node.\n * @param {Array} tags\n */\nexport function fixCaretBetweenTags(tags, TagifyHasFocuse) {\n    tags.forEach(tag => {\n        if( getSetTagData(tag.previousSibling) || !tag.previousSibling ) {\n            var textNode = document.createTextNode(ZERO_WIDTH_CHAR)\n            tag.before(textNode)\n            TagifyHasFocuse && placeCaretAfterNode(textNode)\n        }\n    })\n}\n\n", "export default {\r\n    delimiters          : \",\",            // [RegEx] split tags by any of these delimiters (\"null\" to cancel) Example: \",| |.\"\r\n    pattern             : null,           // RegEx pattern to validate input by. Ex: /[1-9]/\r\n    tagTextProp         : 'value',        // tag data Object property which will be displayed as the tag's text\r\n    maxTags             : Infinity,       // Maximum number of tags\r\n    callbacks           : {},             // Exposed callbacks object to be triggered on certain events\r\n    addTagOnBlur        : true,           // automatically adds the text which was inputed as a tag when blur event happens\r\n    addTagOn            : ['blur', 'tab', 'enter'],  // if the tagify field (in a normal mode) has any non-tag input in it, convert it to a tag on any of these events: blur away from the field, click \"tab\"/\"enter\" key\r\n    onChangeAfterBlur   : true,           // By default, the native way of inputs' onChange events is kept, and it only fires when the field is blured.\r\n    duplicates          : false,          // \"true\" - allow duplicate tags\r\n    whitelist           : [],             // Array of tags to suggest as the user types (can be used along with \"enforceWhitelist\" setting)\r\n    blacklist           : [],             // A list of non-allowed tags\r\n    enforceWhitelist    : false,          // Only allow tags from the whitelist\r\n    userInput           : true,           // disable manually typing/pasting/editing tags (tags may only be added from the whitelist)\r\n    focusable           : true,           // Allow the component as a whole to recieve focus. There are implementations of Tagify without external border and so 'focusability' causes unwanted behaviour\r\n    focusInputOnRemove  : true,           // Refocus the input when a tag is removed\r\n    keepInvalidTags     : false,          // if true, do not remove tags which did not pass validation\r\n    createInvalidTags   : true,           // if false, do not create invalid tags from invalid user input\r\n    mixTagsAllowedAfter : /,|\\.|\\:|\\s/,   // RegEx - Define conditions in which mix-tags content allows a tag to be added after\r\n    mixTagsInterpolator : ['[[', ']]'],   // Interpolation for mix mode. Everything between these will become a tag, if is a valid Object\r\n    backspace           : true,           // false / true / \"edit\"\r\n    skipInvalid         : false,          // If `true`, do not add invalid, temporary, tags before automatically removing them\r\n    pasteAsTags         : true,           // automatically converts pasted text into tags. if \"false\", allows for further text editing\r\n\r\n    editTags            : {\r\n        clicks      : 2,                  // clicks to enter \"edit-mode\": 1 for single click. any other value is considered as double-click\r\n        keepInvalid : true                // keeps invalid edits as-is until `esc` is pressed while in focus\r\n    },              // 1 or 2 clicks to edit a tag. false/null for not allowing editing\r\n    transformTag        : ()=>{},         // Takes a tag input string as argument and returns a transformed value\r\n    trim                : true,           // whether or not the value provided should be trimmed, before being added as a tag\r\n    a11y: {\r\n        focusableTags: false\r\n    },\r\n\r\n    mixMode: {\r\n        insertAfterTag  : '\\u00A0',       // String/Node to inject after a tag has been added (see #588)\r\n    },\r\n\r\n    autoComplete: {\r\n        enabled: true,        // Tries to suggest the input's value while typing (match from whitelist) by adding the rest of term as grayed-out text\r\n        rightKey: false,      // If `true`, when Right key is pressed, use the suggested value to create a tag, else just auto-completes the input. in mixed-mode this is set to \"true\"\r\n        tabKey: false,        // If 'true`, pressing `tab` key would only auto-complete but not also convert to a tag (like `rightKey` does).\r\n    },\r\n\r\n    classNames: {\r\n        namespace            : 'tagify',\r\n        mixMode              : 'tagify--mix',\r\n        selectMode           : 'tagify--select',\r\n        input                : 'tagify__input',\r\n        focus                : 'tagify--focus',\r\n        tagNoAnimation       : 'tagify--noAnim',\r\n        tagInvalid           : 'tagify--invalid',\r\n        tagNotAllowed        : 'tagify--notAllowed',\r\n        scopeLoading         : 'tagify--loading',\r\n        hasMaxTags           : 'tagify--hasMaxTags',\r\n        hasNoTags            : 'tagify--noTags',\r\n        empty                : 'tagify--empty',\r\n        inputInvalid         : 'tagify__input--invalid',\r\n        dropdown             : 'tagify__dropdown',\r\n        dropdownWrapper      : 'tagify__dropdown__wrapper',\r\n        dropdownHeader       : 'tagify__dropdown__header',\r\n        dropdownFooter       : 'tagify__dropdown__footer',\r\n        dropdownItem         : 'tagify__dropdown__item',\r\n        dropdownItemActive   : 'tagify__dropdown__item--active',\r\n        dropdownItemHidden   : 'tagify__dropdown__item--hidden',\r\n        dropdownItemSelected : 'tagify__dropdown__item--selected',\r\n        dropdownInital       : 'tagify__dropdown--initial',\r\n        tag                  : 'tagify__tag',\r\n        tagText              : 'tagify__tag-text',\r\n        tagX                 : 'tagify__tag__removeBtn',\r\n        tagLoading           : 'tagify__tag--loading',\r\n        tagEditing           : 'tagify__tag--editable',\r\n        tagFlash             : 'tagify__tag--flash',\r\n        tagHide              : 'tagify__tag--hide',\r\n\r\n    },\r\n\r\n    dropdown: {\r\n        classname          : '',\r\n        enabled            : 2,      // minimum input characters to be typed for the suggestions dropdown to show\r\n        maxItems           : 10,\r\n        searchKeys         : [\"value\", \"searchBy\"],\r\n        fuzzySearch        : true,\r\n        caseSensitive      : false,\r\n        accentedSearch     : true,\r\n        includeSelectedTags: false,  // Should the suggestions list Include already-selected tags (after filtering)\r\n        escapeHTML         : true,   // escapes HTML entities in the suggestions' rendered text\r\n        highlightFirst     : true,   // highlights first-matched item in the list\r\n        closeOnSelect      : true,   // closes the dropdown after selecting an item, if `enabled:0` (which means always show dropdown)\r\n        clearOnSelect      : true,   // after selecting a suggetion, should the typed text input remain or be cleared\r\n        position           : 'all',  // 'manual' / 'text' / 'all'\r\n        appendTarget       : null    // defaults to document.body once DOM has been loaded\r\n    },\r\n\r\n    hooks: {\r\n        beforeRemoveTag: () => Promise.resolve(),\r\n        beforePaste: () => Promise.resolve(),\r\n        suggestionClick: () => Promise.resolve(),\r\n        beforeKeyDown: () => Promise.resolve(),\r\n    }\r\n}", "import { sameStr, isObject, minify, getNodeHeight, getCaretGlobalPosition } from './helpers'\nimport suggestionsMethods from './suggestions'\n\nexport function initDropdown(){\n    this.dropdown = {}\n\n    // auto-bind \"this\" to all the dropdown methods\n    for( let p in this._dropdown )\n        this.dropdown[p] = typeof this._dropdown[p] === 'function'\n            ? this._dropdown[p].bind(this)\n            : this._dropdown[p]\n\n    this.dropdown.refs()\n    this.DOM.dropdown.__tagify = this\n}\n\nexport default {\n    ...suggestionsMethods,\n\n    refs(){\n        this.DOM.dropdown = this.parseTemplate('dropdown', [this.settings])\n        this.DOM.dropdown.content = this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-wrapper']\")\n    },\n\n    getHeaderRef(){\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-header']\")\n    },\n\n    getFooterRef(){\n        return this.DOM.dropdown.querySelector(\"[data-selector='tagify-suggestions-footer']\")\n    },\n\n    getAllSuggestionsRefs(){\n        return [...this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector)]\n    },\n\n    /**\n     * shows the suggestions select box\n     * @param {String} value [optional, filter the whitelist by this value]\n     */\n    show( value ){\n        var _s = this.settings,\n            firstListItem,\n            firstListItemValue,\n            allowNewTags = _s.mode == 'mix' && !_s.enforceWhitelist,\n            noWhitelist =  !_s.whitelist || !_s.whitelist.length,\n            noMatchListItem,\n            isManual = _s.dropdown.position == 'manual';\n\n        // if text still exists in the input, and `show` method has no argument, then the input's text should be used\n        value = value === undefined ? this.state.inputText : value\n\n        // ⚠️ Do not render suggestions list  if:\n        // 1. there's no whitelist (can happen while async loading) AND new tags arn't allowed\n        // 2. dropdown is disabled\n        // 3. loader is showing (controlled outside of this code)\n        if( (noWhitelist && !allowNewTags && !_s.templates.dropdownItemNoMatch)\n            || _s.dropdown.enabled === false\n            || this.state.isLoading\n            || this.settings.readonly )\n            return;\n\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\n\n        // if no value was supplied, show all the \"whitelist\" items in the dropdown\n        // @type [Array] listItems\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        // trigger at this exact point to let the developer the chance to manually set \"this.suggestedListItems\"\n        if( value && !this.suggestedListItems.length ){\n            this.trigger('dropdown:noMatch', value)\n\n            if( _s.templates.dropdownItemNoMatch )\n                noMatchListItem = _s.templates.dropdownItemNoMatch.call(this, {value})\n        }\n\n        // if \"dropdownItemNoMatch\" was not defined, procceed regular flow.\n        //\n        if( !noMatchListItem ){\n            // in mix-mode, if the value isn't included in the whilelist & \"enforceWhitelist\" setting is \"false\",\n            // then add a custom suggestion item to the dropdown\n            if( this.suggestedListItems.length ){\n                if( value   &&   allowNewTags   &&   !this.state.editing.scope  &&  !sameStr(this.suggestedListItems[0].value, value) )\n                    this.suggestedListItems.unshift({value})\n            }\n            else{\n                if( value   &&   allowNewTags  &&  !this.state.editing.scope ){\n                    this.suggestedListItems = [{value}]\n                }\n                // hide suggestions list if no suggestion matched\n                else{\n                    this.input.autocomplete.suggest.call(this);\n                    this.dropdown.hide()\n                    return;\n                }\n            }\n\n            firstListItem =  this.suggestedListItems[0]\n            firstListItemValue = \"\"+(isObject(firstListItem) ? firstListItem.value : firstListItem)\n\n            if( _s.autoComplete && firstListItemValue ){\n                // only fill the sugegstion if the value of the first list item STARTS with the input value (regardless of \"fuzzysearch\" setting)\n                if( firstListItemValue.indexOf(value) == 0 )\n                    this.input.autocomplete.suggest.call(this, firstListItem)\n            }\n        }\n\n        this.dropdown.fill(noMatchListItem)\n\n        if( _s.dropdown.highlightFirst ) {\n            this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(_s.classNames.dropdownItemSelector))\n        }\n\n        // bind events, exactly at this stage of the code. \"dropdown.show\" method is allowed to be\n        // called multiple times, regardless if the dropdown is currently visible, but the events-binding\n        // should only be called if the dropdown wasn't previously visible.\n        if( !this.state.dropdown.visible )\n            // timeout is needed for when pressing arrow down to show the dropdown,\n            // so the key event won't get registered in the dropdown events listeners\n            setTimeout(this.dropdown.events.binding.bind(this))\n\n        // set the dropdown visible state to be the same as the searched value.\n        // MUST be set *before* position() is called\n        this.state.dropdown.visible = value || true\n        this.state.dropdown.query = value\n\n        this.setStateSelection()\n\n        // try to positioning the dropdown (it might not yet be on the page, doesn't matter, next code handles this)\n        if( !isManual ){\n            // a slight delay is needed if the dropdown \"position\" setting is \"text\", and nothing was typed in the input,\n            // so sadly the \"getCaretGlobalPosition\" method doesn't recognize the caret position without this delay\n            setTimeout(() => {\n                this.dropdown.position()\n                this.dropdown.render()\n            })\n        }\n\n        // a delay is needed because of the previous delay reason.\n        // this event must be fired after the dropdown was rendered & positioned\n        setTimeout(() => {\n            this.trigger(\"dropdown:show\", this.DOM.dropdown)\n        })\n    },\n\n    /**\n     * Hides the dropdown (if it's not managed manually by the developer)\n     * @param {Boolean} overrideManual\n     */\n    hide( overrideManual ){\n        var {scope, dropdown} = this.DOM,\n            isManual = this.settings.dropdown.position == 'manual' && !overrideManual;\n\n        // if there's no dropdown, this means the dropdown events aren't binded\n        if( !dropdown || !document.body.contains(dropdown) || isManual ) return;\n\n        window.removeEventListener('resize', this.dropdown.position)\n        this.dropdown.events.binding.call(this, false) // unbind all events\n\n        // if the dropdown is open, and the input (scope) is clicked,\n        // the dropdown should be now \"close\", and the next click (on the scope)\n        // should re-open it, and without a timeout, clicking to close will re-open immediately\n        //  clearTimeout(this.dropdownHide__bindEventsTimeout)\n        //  this.dropdownHide__bindEventsTimeout = setTimeout(this.events.binding.bind(this), 250)  // re-bind main events\n\n\n        scope.setAttribute(\"aria-expanded\", false)\n        dropdown.parentNode.removeChild(dropdown)\n\n        // scenario: clicking the scope to show the dropdown, clicking again to hide -> calls dropdown.hide() and then re-focuses the input\n        // which casues another onFocus event, which checked \"this.state.dropdown.visible\" and see it as \"false\" and re-open the dropdown\n        setTimeout(() => {\n            this.state.dropdown.visible = false\n        }, 100)\n\n        this.state.dropdown.query =\n        this.state.ddItemData =\n        this.state.ddItemElm =\n        this.state.selection = null\n\n        // if the user closed the dropdown (in mix-mode) while a potential tag was detected, flag the current tag\n        // so the dropdown won't be shown on following user input for that \"tag\"\n        if( this.state.tag && this.state.tag.value.length ){\n            this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag\n        }\n\n        this.trigger(\"dropdown:hide\", dropdown)\n\n        return this\n    },\n\n    /**\n     * Toggles dropdown show/hide\n     * @param {Boolean} show forces the dropdown to show\n     */\n    toggle(show){\n        this.dropdown[this.state.dropdown.visible && !show ? 'hide' : 'show']()\n    },\n\n    getAppendTarget() {\n        var _sd = this.settings.dropdown;\n        return typeof _sd.appendTarget === 'function' ? _sd.appendTarget() : _sd.appendTarget;\n    },\n\n    render(){\n        // let the element render in the DOM first, to accurately measure it.\n        // this.DOM.dropdown.style.cssText = \"left:-9999px; top:-9999px;\";\n        var ddHeight = getNodeHeight(this.DOM.dropdown),\n            _s = this.settings,\n            appendTarget = this.dropdown.getAppendTarget();\n\n        if( _s.dropdown.enabled === false ) return this;\n\n        this.DOM.scope.setAttribute(\"aria-expanded\", true)\n\n        // if the dropdown has yet to be appended to the DOM,\n        // append the dropdown to the body element & handle events\n        if( !document.body.contains(this.DOM.dropdown) ){\n            this.DOM.dropdown.classList.add( _s.classNames.dropdownInital )\n            this.dropdown.position(ddHeight)\n            appendTarget.appendChild(this.DOM.dropdown)\n\n            setTimeout(() =>\n                this.DOM.dropdown.classList.remove( _s.classNames.dropdownInital )\n            )\n        }\n\n        return this\n    },\n\n    /**\n     * re-renders the dropdown content element (see \"dropdownContent\" in templates file)\n     * @param {String/Array} HTMLContent - optional\n     */\n    fill( HTMLContent ){\n        HTMLContent = typeof HTMLContent == 'string'\n            ? HTMLContent\n            : this.dropdown.createListHTML(HTMLContent || this.suggestedListItems)\n\n        var dropdownContent = this.settings.templates.dropdownContent.call(this, HTMLContent)\n\n        this.DOM.dropdown.content.innerHTML = minify(dropdownContent)\n    },\n\n    /**\n     * Re-renders only the header & footer.\n     * Used when selecting a suggestion and it is wanted that the suggestions dropdown stays open.\n     * Since the list of sugegstions is not being re-rendered completely every time a suggestion is selected (the item is transitioned-out)\n     * then the header & footer should be kept in sync with the suggestions data change\n     */\n    fillHeaderFooter(){\n        var suggestions = this.dropdown.filterListItems(this.state.dropdown.query),\n            newHeaderElem = this.parseTemplate('dropdownHeader', [suggestions]),\n            newFooterElem = this.parseTemplate('dropdownFooter', [suggestions]),\n            headerRef = this.dropdown.getHeaderRef(),\n            footerRef = this.dropdown.getFooterRef();\n\n        newHeaderElem && headerRef?.parentNode.replaceChild(newHeaderElem, headerRef)\n        newFooterElem && footerRef?.parentNode.replaceChild(newFooterElem, footerRef)\n    },\n\n    /**\n     * dropdown positioning logic\n     * (shown above/below or next to typed text for mix-mode)\n     */\n    position( ddHeight ){\n        var _sd = this.settings.dropdown,\n            appendTarget = this.dropdown.getAppendTarget();\n\n        if( _sd.position == 'manual' || !appendTarget) return\n\n        var rect, top, bottom, left, width, ancestorsOffsets,\n            isPlacedAbove, hasSpaceOnRight,\n            cssTop, cssLeft,\n            ddElm = this.DOM.dropdown,\n            isRTL = _sd.RTL,\n            isDefaultAppendTarget = appendTarget === document.body,\n            isSelfAppended = appendTarget === this.DOM.scope,\n            appendTargetScrollTop = isDefaultAppendTarget ? window.pageYOffset : appendTarget.scrollTop,\n            root = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement,\n            viewportHeight = root.clientHeight,\n            viewportWidth = Math.max(root.clientWidth || 0, window.innerWidth || 0),\n            positionTo = viewportWidth > 480 ? _sd.position : 'all',\n            ddTarget = this.DOM[positionTo == 'input' ? 'input' : 'scope'],\n            MIN_DISTANCE_FROM_VIEWPORT_H_EDGE = 120;\n\n        ddHeight = ddHeight || ddElm.clientHeight\n\n        function getAncestorsOffsets(p){\n            var top = 0, left = 0;\n\n            p = p.parentNode;\n\n            // when in element-fullscreen mode, do not go above the fullscreened-element\n            while(p && p != root){\n                top += p.offsetTop || 0\n                left += p.offsetLeft || 0\n                p = p.parentNode\n            }\n\n            return {top, left};\n        }\n\n        function getAccumulatedAncestorsScrollTop() {\n            var scrollTop = 0,\n                p = _sd.appendTarget.parentNode;\n\n            while(p){\n                scrollTop += p.scrollTop || 0;\n                p = p.parentNode\n            }\n\n            return scrollTop;\n        }\n\n        if( !this.state.dropdown.visible ) return\n\n        if( positionTo == 'text' ){\n            rect   = getCaretGlobalPosition()\n            bottom = rect.bottom\n            top    = rect.top\n            left   = rect.left\n            width  = 'auto'\n        }\n\n        else{\n            ancestorsOffsets = getAncestorsOffsets(appendTarget)\n            rect   = ddTarget.getBoundingClientRect()\n            top    = isSelfAppended ? -1 : rect.top - ancestorsOffsets.top\n            bottom = (isSelfAppended ? rect.height : rect.bottom - ancestorsOffsets.top) - 1\n            left   = isSelfAppended ? -1 : rect.left - ancestorsOffsets.left\n            width  = rect.width + 'px'\n        }\n\n        // if the \"append target\" isn't the default, correct the `top` variable by ignoring any scrollTop of the target's Ancestors\n        if( !isDefaultAppendTarget ) {\n            let accumulatedAncestorsScrollTop = getAccumulatedAncestorsScrollTop()\n            top += accumulatedAncestorsScrollTop\n            bottom += accumulatedAncestorsScrollTop\n        }\n\n        top = Math.floor(top)\n        bottom = Math.ceil(bottom)\n\n        isPlacedAbove = _sd.placeAbove ?? viewportHeight - rect.bottom < ddHeight\n        hasSpaceOnRight = viewportWidth - left < MIN_DISTANCE_FROM_VIEWPORT_H_EDGE;\n\n        // flip vertically if there is no space for the dropdown below the input\n        cssTop = (isPlacedAbove ? top : bottom) + appendTargetScrollTop;\n\n        // \"pageXOffset\" property is an alias for \"scrollX\"\n        cssLeft = (left + (isRTL ? (rect.width || 0) : 0) + window.pageXOffset);\n\n        // check if there's enough space on the right-side of the viewport,\n        // because the element is positioned to the right of the caret, which might need to be changed.\n        if( positionTo == 'text' && hasSpaceOnRight ) {\n            cssLeft = `right: 0;`;\n        }\n        else {\n            cssLeft = `left: ${cssLeft}px;`;\n        }\n\n        // rtl = rtl ?? viewportWidth -\n        ddElm.style.cssText = `${cssLeft} top: ${cssTop}px; min-width: ${width}; max-width: ${width}`;\n\n        ddElm.setAttribute('placement', isPlacedAbove ? 'top' : 'bottom')\n        ddElm.setAttribute('position', positionTo)\n    },\n}\n", "import { isObject, escapeHTML, extend, unaccent, logger } from './helpers'\n\n\n/**\n * Tagify's dropdown suggestions-related logic\n */\n\nexport default {\n    events : {\n        /**\n         * Events should only be binded when the dropdown is rendered and removed when isn't\n         * because there might be multiple Tagify instances on a certain page\n         * @param  {Boolean} bindUnbind [optional. true when wanting to unbind all the events]\n         */\n        binding( bindUnbind = true ){\n            // references to the \".bind()\" methods must be saved so they could be unbinded later\n            var _CB = this.dropdown.events.callbacks,\n                // callback-refs\n                _CBR = (this.listeners.dropdown = this.listeners.dropdown || {\n                    position          : this.dropdown.position.bind(this, null),\n                    onKeyDown         : _CB.onKeyDown.bind(this),\n                    onMouseOver       : _CB.onMouseOver.bind(this),\n                    onMouseLeave      : _CB.onMouseLeave.bind(this),\n                    onClick           : _CB.onClick.bind(this),\n                    onScroll          : _CB.onScroll.bind(this),\n                }),\n                action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n            if( this.settings.dropdown.position != 'manual' ){\n                document[action]('scroll', _CBR.position, true)\n                window[action]('resize', _CBR.position)\n                window[action]('keydown', _CBR.onKeyDown)\n            }\n\n            this.DOM.dropdown[action]('mouseover', _CBR.onMouseOver)\n            this.DOM.dropdown[action]('mouseleave', _CBR.onMouseLeave)\n            this.DOM.dropdown[action]('mousedown', _CBR.onClick)\n            this.DOM.dropdown.content[action]('scroll', _CBR.onScroll)\n        },\n\n        callbacks : {\n            onKeyDown(e){\n                // ignore keys during IME composition\n                if( !this.state.hasFocus || this.state.composing )\n                    return\n\n                // get the \"active\" element, and if there was none (yet) active, use first child\n                var _s = this.settings,\n                    includeSelectedTags = _s.dropdown.includeSelectedTags,\n                    selectedElm = this.DOM.dropdown.querySelector(_s.classNames.dropdownItemActiveSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm),\n                    isMixMode = _s.mode == 'mix',\n                    isSelectMode = _s.mode == 'select';\n\n                _s.hooks.beforeKeyDown(e, {tagify:this})\n                    .then(result => {\n                        switch( e.key ){\n                            case 'ArrowDown' :\n                            case 'ArrowUp' :\n                            case 'Down' :  // >IE11\n                            case 'Up' : {  // >IE11\n                                e.preventDefault()\n                                var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n                                    actionUp = e.key == 'ArrowUp' || e.key == 'Up';\n\n                                if( selectedElm ) {\n                                    selectedElm = this.dropdown.getNextOrPrevOption(selectedElm, !actionUp)\n                                }\n\n                                // if no element was found OR current item is not a \"real\" item, loop\n                                if( !selectedElm || !selectedElm.matches(_s.classNames.dropdownItemSelector) ){\n                                    selectedElm = dropdownItems[actionUp ? dropdownItems.length - 1 : 0];\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                // selectedElm.scrollIntoView({inline: 'nearest', behavior: 'smooth'})\n                                break;\n                            }\n                            case 'PageUp':\n                            case 'PageDown': {\n                                e.preventDefault()\n                                const dropdownItems = this.dropdown.getAllSuggestionsRefs()\n                                const itemsPerPage = Math.floor(this.DOM.dropdown.content.clientHeight / dropdownItems[0]?.offsetHeight) || 1\n                                const isPageUp = e.key === 'PageUp'\n\n                                if (selectedElm) {\n                                    const currentIndex = dropdownItems.indexOf(selectedElm)\n                                    const targetIndex = isPageUp\n                                        ? Math.max(0, currentIndex - itemsPerPage)\n                                        : Math.min(dropdownItems.length - 1, currentIndex + itemsPerPage)\n                                    selectedElm = dropdownItems[targetIndex]\n                                } else {\n                                    selectedElm = dropdownItems[0]\n                                }\n\n                                this.dropdown.highlightOption(selectedElm, true)\n                                break;\n                            }\n                            case 'Home':\n                            case 'End': {\n                                e.preventDefault()\n                                const dropdownItems = this.dropdown.getAllSuggestionsRefs()\n                                selectedElm = dropdownItems[e.key === 'Home' ? 0 : dropdownItems.length - 1]\n                                this.dropdown.highlightOption(selectedElm, true)\n                                break;\n                            }\n                            case 'Escape' :\n                            case 'Esc': // IE11\n                                this.dropdown.hide();\n                                break;\n\n                            case 'ArrowRight' :\n                                // do not continue if the left arrow key was pressed while typing, because assuming the user wants to bypass any of the below logic and edit the content without intervention.\n                                // also do not procceed if a tag should be created when the setting `autoComplete.rightKey` is set to `true`\n                                if( this.state.actions.ArrowLeft || _s.autoComplete.rightKey )\n                                    return\n                            case 'Tab' : {\n                                let shouldAutocompleteOnKey = !_s.autoComplete.rightKey || !_s.autoComplete.tabKey\n\n                                // in mix-mode, treat arrowRight like Enter key, so a tag will be created\n                                if( !isMixMode && !isSelectMode && selectedElm && shouldAutocompleteOnKey && !this.state.editing && selectedElmData ){\n                                    e.preventDefault() // prevents blur so the autocomplete suggestion will not become a tag\n                                    var value = this.dropdown.getMappedValue(selectedElmData)\n\n                                    this.state.autoCompleteData = selectedElmData;\n                                    this.input.autocomplete.set.call(this, value)\n                                    return false\n                                }\n                                return true\n                            }\n                            case 'Enter' : {\n                                e.preventDefault()\n\n                                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't execute any if its logic.\n                                // a `100ms` is a good-enough timeout after some testing\n                                this.state.actions.selectOption = true;\n                                setTimeout(()=> this.state.actions.selectOption = false, 100)\n\n                                _s.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                                    .then(() => {\n                                        if( selectedElm ){\n                                            var nextOrPrevOption = includeSelectedTags ? selectedElm : this.dropdown.getNextOrPrevOption(selectedElm, !actionUp);\n\n                                            this.dropdown.selectOption(selectedElm, e, () => {\n                                                // highlight next option\n                                                if(nextOrPrevOption) {\n                                                    var nextOrPrevOptionValue = nextOrPrevOption.getAttribute('value')\n                                                    nextOrPrevOption = this.dropdown.getSuggestionNodeByValue(nextOrPrevOptionValue)\n                                                    this.dropdown.highlightOption(nextOrPrevOption)\n                                                }\n                                            })\n\n                                            return\n                                        }\n                                        else\n                                            this.dropdown.hide()\n\n                                        if( !isMixMode )\n                                            this.addTags(this.state.inputText.trim(), true)\n                                    })\n                                    .catch(err => logger.warn(err))\n\n                                break;\n                            }\n                            case 'Backspace' : {\n                                if( isMixMode || this.state.editing.scope ) return;\n\n                                const value = this.input.raw.call(this)\n\n                                if( value == \"\" || value.charCodeAt(0) == 8203 ){\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0)\n                                }\n                            }\n                        }\n                    })\n            },\n\n            onMouseOver(e){\n                var ddItem = e.target.closest(this.settings.classNames.dropdownItemSelector)\n                // event delegation check\n                this.dropdown.highlightOption(ddItem)\n            },\n\n            onMouseLeave(e){\n                // de-highlight any previously highlighted option\n                this.dropdown.highlightOption()\n            },\n\n            onClick(e){\n                if( e.button != 0 || e.target == this.DOM.dropdown || e.target == this.DOM.dropdown.content ) return; // allow only mouse left-clicks\n\n                var selectedElm = e.target.closest(this.settings.classNames.dropdownItemSelector),\n                    selectedElmData = this.dropdown.getSuggestionDataByNode(selectedElm)\n\n                // temporary set the \"actions\" state to indicate to the main \"blur\" event it shouldn't execute any if its logic.\n                // a `100ms` is a good-enough timeout after some testing\n                this.state.actions.selectOption = true;\n                setTimeout(()=> this.state.actions.selectOption = false, 100)\n\n                this.settings.hooks.suggestionClick(e, {tagify:this, tagData:selectedElmData, suggestionElm:selectedElm})\n                    .then(() => {\n                        if( selectedElm )\n                            this.dropdown.selectOption(selectedElm, e)\n                        else\n                            this.dropdown.hide()\n                    })\n                    .catch(err => logger.warn(err))\n            },\n\n            onScroll(e){\n                var elm = e.target,\n                    pos = elm.scrollTop / (elm.scrollHeight - elm.parentNode.clientHeight) * 100;\n\n                this.trigger(\"dropdown:scroll\", {percentage:Math.round(pos)})\n            },\n        }\n    },\n\n    /**\n     * fill data into the suggestions list\n     * (mainly used to update the list when removing tags while the suggestions dropdown is visible, so they will be re-added to the list. not efficient)\n     */\n    refilter( value ){\n        value = value || this.state.dropdown.query || ''\n        this.suggestedListItems = this.dropdown.filterListItems(value)\n\n        this.dropdown.fill()\n\n        if( !this.suggestedListItems.length )\n            this.dropdown.hide()\n\n        this.trigger(\"dropdown:updated\", this.DOM.dropdown)\n    },\n\n    /**\n     * Given a suggestion-item, return the data associated with it\n     * @param {HTMLElement} tagElm\n     * @returns Object\n     */\n    getSuggestionDataByNode( tagElm ){\n        var item, value = tagElm && tagElm.getAttribute('value')\n\n        for(var i = this.suggestedListItems.length; i--; ) {\n            item = this.suggestedListItems[i]\n            if( isObject(item) && item.value == value ) return item\n            // for primitive whitelist items:\n            else if( item == value ) return {value: item}\n        }\n    },\n\n    getSuggestionNodeByValue( value ){\n        var dropdownItems = this.dropdown.getAllSuggestionsRefs()\n        return dropdownItems.find(item => item.getAttribute('value') === value);\n    },\n\n    getNextOrPrevOption(selected, next = true) {\n        var dropdownItems = this.dropdown.getAllSuggestionsRefs(),\n            selectedIdx = dropdownItems.findIndex(item => item === selected);\n\n        return next ? dropdownItems[selectedIdx + 1] : dropdownItems[selectedIdx - 1]\n    },\n\n    /**\n     * mark the currently active suggestion option\n     * @param {Object}  elm            option DOM node\n     * @param {Boolean} adjustScroll   when navigation with keyboard arrows (up/down), auto-scroll to always show the highlighted element\n     */\n    highlightOption( elm, adjustScroll ){\n        var className = this.settings.classNames.dropdownItemActive,\n            itemData;\n\n        // focus casues a bug in Firefox with the placeholder been shown on the input element\n        // if( this.settings.dropdown.position != 'manual' )\n        //     elm.focus();\n\n        if( this.state.ddItemElm ){\n            this.state.ddItemElm.classList.remove(className)\n            this.state.ddItemElm.removeAttribute(\"aria-selected\")\n        }\n\n        if( !elm ){\n            this.state.ddItemData = null\n            this.state.ddItemElm = null\n            this.input.autocomplete.suggest.call(this)\n            return;\n        }\n\n        itemData = this.dropdown.getSuggestionDataByNode(elm)\n        this.state.ddItemData = itemData\n        this.state.ddItemElm = elm\n\n        // this.DOM.dropdown.querySelectorAll(\".\" + this.settings.classNames.dropdownItemActive).forEach(activeElm => activeElm.classList.remove(className));\n        elm.classList.add(className);\n        elm.setAttribute(\"aria-selected\", true)\n\n        if( adjustScroll )\n            elm.parentNode.scrollTop = elm.clientHeight + elm.offsetTop - elm.parentNode.clientHeight\n\n        // Try to autocomplete the typed value with the currently highlighted dropdown item\n        if( this.settings.autoComplete ){\n            this.input.autocomplete.suggest.call(this, itemData)\n            this.dropdown.position() // suggestions might alter the height of the tagify wrapper because of unkown suggested term length that could drop to the next line\n        }\n    },\n\n    /**\n     * Create a tag from the currently active suggestion option\n     * @param {Object} elm  DOM node to select\n     * @param {Object} event The original Click event, if available (since keyboard ENTER key also triggers this method)\n     */\n    selectOption( elm, event, onSelect ){\n        var _s = this.settings,\n            includeSelectedTags = _s.dropdown.includeSelectedTags,\n            {clearOnSelect, closeOnSelect} = _s.dropdown;\n\n        if( !elm ) {\n            this.addTags(this.state.inputText, true)\n            closeOnSelect && this.dropdown.hide()\n            return;\n        }\n\n        event = event || {}\n\n        // if in edit-mode, do not continue but instead replace the tag's text.\n        // the scenario is that \"addTags\" was called from a dropdown suggested option selected while editing\n\n        var value = elm.getAttribute('value'),\n            isNoMatch = value == 'noMatch',\n            isMixMode = _s.mode == 'mix',\n            tagData = this.suggestedListItems.find(item => (item.value ?? item) == value)\n\n        // The below event must be triggered, regardless of anything else which might go wrong\n        this.trigger('dropdown:select', {data:tagData, elm, event})\n\n        if( !tagData && !isNoMatch ){\n            closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n            return\n        }\n\n        if( this.state.editing ) {\n            let normalizedTagData = this.normalizeTags([tagData])[0]\n            tagData = _s.transformTag.call(this, normalizedTagData) || normalizedTagData\n\n            // normalizing value, because \"tagData\" might be a string, and therefore will not be able to extend the object\n            this.onEditTagDone(null, extend({__isValid: true}, tagData))\n        }\n        // Tagify instances should re-focus to the input element once an option was selected, to allow continuous typing\n        else {\n            this[isMixMode ? \"addMixTags\" : \"addTags\"]([tagData || this.input.raw.call(this)], clearOnSelect)\n        }\n\n        if( !isMixMode && !this.DOM.input.parentNode )\n            return\n\n        setTimeout(() => {\n            this.DOM.input.focus()\n            this.toggleFocusClass(true)\n        })\n\n        closeOnSelect && setTimeout(this.dropdown.hide.bind(this))\n\n        // execute these tasks once a suggestion has been selected\n        if(includeSelectedTags) {\n            onSelect && onSelect()\n        }\n\n        // if the selected suggestion is removed after being selected, more things things needs to be done:\n        else {\n            elm.addEventListener('transitionend', () => {\n                this.dropdown.fillHeaderFooter()\n\n                setTimeout(() => {\n                    elm.remove()\n                    this.dropdown.refilter()\n                    onSelect && onSelect()\n                }, 100)\n            }, {once: true})\n\n            // hide selected suggestion\n            elm.classList.add(this.settings.classNames.dropdownItemHidden)\n        }\n    },\n\n    // adds all the suggested items, including the ones which are not currently rendered,\n    // unless specified otherwise (by the \"onlyRendered\" argument)\n    selectAll( onlyRendered ){\n        // having suggestedListItems with items messes with \"normalizeTags\" when wanting\n        // to add all tags\n        this.suggestedListItems.length = 0;\n        this.dropdown.hide()\n\n        this.dropdown.filterListItems('');\n\n        var tagsToAdd = this.dropdown.filterListItems('');\n\n        if( !onlyRendered )\n            tagsToAdd = this.state.dropdown.suggestions\n\n        // some whitelist items might have already been added as tags so when addings all of them,\n        // skip adding already-added ones, so best to use \"filterListItems\" method over \"settings.whitelist\"\n        this.addTags(tagsToAdd, true)\n        return this\n    },\n\n    /**\n     * returns an HTML string of the suggestions' list items\n     * @param {String} value string t\n     * o filter the whitelist by\n     * @param {Object} options \"exact\" - for exact complete match\n     * @return {Array} list of filtered whitelist items according to the settings provided and current value\n     */\n    filterListItems( value, options ){\n        var _s = this.settings,\n            _sd = _s.dropdown,\n            options = options || {},\n            list = [],\n            exactMatchesList = [],\n            whitelist = _s.whitelist,\n            suggestionsCount = _sd.maxItems >= 0 ? _sd.maxItems : Infinity,\n            includeSelectedTags = _sd.includeSelectedTags,\n            hasCustomSort = typeof _sd.sortby == 'function',\n            searchKeys = _sd.searchKeys,\n            whitelistItem,\n            valueIsInWhitelist,\n            searchBy,\n            isDuplicate,\n            niddle,\n            i = 0;\n\n        value = (_s.mode == 'select' && this.value.length && this.value[0][_s.tagTextProp] == value\n            ? '' // do not filter if the tag, which is already selecetd in \"select\" mode, is the same as the typed text\n            : value);\n\n        if( !value || !searchKeys.length ){\n            list = includeSelectedTags\n                ? whitelist\n                : whitelist.filter(item => !this.isTagDuplicate( isObject(item) ? item.value : item )) // don't include tags which have already been added.\n\n            var filteredList = hasCustomSort\n                ? _sd.sortby(list, niddle)\n                : list.slice(0, suggestionsCount); // respect \"maxItems\" dropdown setting\n\n            this.state.dropdown.suggestions = filteredList;\n\n            return filteredList;\n        }\n\n        niddle = _sd.caseSensitive\n            ? \"\"+value\n            : (\"\"+value).toLowerCase()\n\n        // checks if ALL of the words in the search query exists in the current whitelist item, regardless of their order\n        function stringHasAll(s, query){\n            return query.toLowerCase().split(' ').every(q => s.includes(q.toLowerCase()))\n        }\n\n        for( ; i < whitelist.length; i++ ){\n            let startsWithMatch, exactMatch;\n\n            whitelistItem = whitelist[i] instanceof Object ? whitelist[i] : { value:whitelist[i] } //normalize value as an Object\n\n            let itemWithoutSearchKeys = !Object.keys(whitelistItem).some(k => searchKeys.includes(k) ),\n                _searchKeys = itemWithoutSearchKeys ? [\"value\"] : searchKeys\n\n            if( _sd.fuzzySearch && !options.exact ){\n                searchBy = _searchKeys.reduce((values, k) => values + \" \" + (whitelistItem[k]||\"\"), \"\").toLowerCase().trim()\n\n                if( _sd.accentedSearch ){\n                    searchBy = unaccent(searchBy)\n                    niddle = unaccent(niddle)\n                }\n\n                startsWithMatch = searchBy.indexOf(niddle) == 0\n                exactMatch = searchBy === niddle\n                valueIsInWhitelist = stringHasAll(searchBy, niddle)\n            }\n\n            else {\n                startsWithMatch = true;\n                valueIsInWhitelist = _searchKeys.some(k => {\n                    var v = '' + (whitelistItem[k] || '') // if key exists, cast to type String\n\n                    if( _sd.accentedSearch ){\n                        v = unaccent(v)\n                        niddle = unaccent(niddle)\n                    }\n\n                    if( !_sd.caseSensitive )\n                        v = v.toLowerCase()\n\n                    exactMatch = v === niddle\n\n                    return options.exact\n                        ? v === niddle\n                        : v.indexOf(niddle) == 0\n                })\n            }\n\n            isDuplicate = !_sd.includeSelectedTags && this.isTagDuplicate( isObject(whitelistItem) ? whitelistItem.value : whitelistItem )\n\n            // match for the value within each \"whitelist\" item\n            if( valueIsInWhitelist && !isDuplicate )\n                if( exactMatch && startsWithMatch)\n                    exactMatchesList.push(whitelistItem)\n                else if( _sd.sortby == 'startsWith' && startsWithMatch )\n                    list.unshift(whitelistItem)\n                else\n                    list.push(whitelistItem)\n        }\n\n        this.state.dropdown.suggestions = exactMatchesList.concat(list);\n\n        // custom sorting function\n        var filteredList = hasCustomSort\n            ? _sd.sortby(exactMatchesList.concat(list), niddle)\n            : exactMatchesList.concat(list).slice(0, suggestionsCount)\n\n        this.state.dropdown.suggestions = filteredList;\n        return filteredList\n    },\n\n    /**\n     * Returns the final value of a tag data (object) with regards to the \"mapValueTo\" dropdown setting\n     * @param {Object} tagData\n     * @returns\n     */\n    getMappedValue(tagData){\n        var mapValueTo = this.settings.dropdown.mapValueTo,\n            value = (mapValueTo\n                ? typeof mapValueTo == 'function' ? mapValueTo(tagData) : (tagData[mapValueTo] || tagData.value)\n                : tagData.value);\n\n        return value\n    },\n\n    /**\n     * Creates the dropdown items' HTML\n     * @param  {Array} sugegstionsList  [Array of Objects]\n     * @return {String}\n     */\n    createListHTML( sugegstionsList ){\n        return extend([], sugegstionsList).map((suggestion, idx) => {\n            if( typeof suggestion == 'string' || typeof suggestion == 'number' )\n                suggestion = {value:suggestion}\n\n            var mappedValue = this.dropdown.getMappedValue(suggestion);\n\n            mappedValue = (typeof mappedValue == 'string' && this.settings.dropdown.escapeHTML)\n                ? escapeHTML(mappedValue)\n                : mappedValue;\n\n            return this.settings.templates.dropdownItem.apply(this, [{...suggestion, mappedValue}, this])\n        }).join(\"\")\n    }\n}", "const VERSION = 1; // current version of persisted data. if code change breaks persisted data, verison number should be bumped.\nconst STORE_KEY = '@yaireo/tagify/'\n\nexport const getPersistedData = id => key => {\n    if( !id ) return;\n\n    // if \"persist\" is \"false\", do not save to localstorage\n    let customKey = '/'+key,\n        persistedData,\n        currentStorageVersion = localStorage?.getItem(STORE_KEY + id + '/v')\n\n    if( currentStorageVersion === VERSION){\n        try{ persistedData = JSON.parse(localStorage[STORE_KEY + id + customKey]) }\n        catch(err){}\n    }\n\n    return persistedData\n}\n\nexport const setPersistedData = id => {\n    if( !id ) return () => {};\n\n    // for storage invalidation\n    localStorage?.setItem(STORE_KEY + id + '/v', VERSION)\n\n    return (data, key) => {\n        let customKey = '/'+key,\n            persistedData = JSON.stringify(data)\n\n        if( data && key ){\n            localStorage?.setItem(STORE_KEY + id + customKey, persistedData)\n            dispatchEvent( new Event('storage') )\n        }\n    }\n}\n\nexport const clearPersistedData = id => key => {\n    const base = STORE_KEY + '/' + id + '/';\n\n    // delete specific key in the storage\n    if( key )\n        localStorage.removeItem(base + key)\n\n    // delete all keys in the storage with a specific tagify id\n    else {\n        for(let k in localStorage)\n            if( k.includes(base) )\n                localStorage.removeItem(k)\n    }\n}\n", "export default {\r\n    empty      : \"empty\",\r\n    exceed     : \"number of tags exceeded\",\r\n    pattern    : \"pattern mismatch\",\r\n    duplicate  : \"already exists\",\r\n    notAllowed : \"not allowed\"\r\n}", "import {ZERO_WIDTH_UNICODE_CHAR} from './constants'\n\nexport default {\n    /**\n     *\n     * @param {DOM Object} input     Original input DOm element\n     * @param {Object}     settings  Tagify instance settings Object\n     */\n    wrapper(input, _s){\n        return `<tags class=\"${_s.classNames.namespace} ${_s.mode ? `${_s.classNames[_s.mode + \"Mode\"]}` : \"\"} ${input.className}\"\n                    ${_s.readonly ? 'readonly' : ''}\n                    ${_s.disabled ? 'disabled' : ''}\n                    ${_s.required ? 'required' : ''}\n                    ${_s.mode === 'select' ? \"spellcheck='false'\" : ''}\n                    tabIndex=\"-1\">\n                    ${this.settings.templates.input.call(this)}\n                ${ZERO_WIDTH_UNICODE_CHAR}\n        </tags>`\n    },\n\n    input() {\n        var _s = this.settings,\n            placeholder = _s.placeholder || ZERO_WIDTH_UNICODE_CHAR;\n\n        return `<span ${!_s.readonly && _s.userInput ? 'contenteditable' : ''} data-can-editable tabIndex=\"0\" data-placeholder=\"${placeholder}\" aria-placeholder=\"${_s.placeholder || ''}\"\n                    class=\"${_s.classNames.input}\"\n                    role=\"textbox\"\n                    autocapitalize=\"false\"\n                    autocorrect=\"off\"\n                    aria-autocomplete=\"both\"\n                    aria-multiline=\"${_s.mode=='mix'?true:false}\"></span>`\n    },\n\n    tag(tagData, {settings: _s}){\n        return `<tag title=\"${(tagData.title || tagData.value)}\"\n                    contenteditable='false'\n                    tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\"\n                    class=\"${_s.classNames.tag} ${tagData.class || \"\"}\"\n                    ${this.getAttributes(tagData)}>\n            <x title='' tabIndex=\"${_s.a11y.focusableTags ? 0 : -1}\" class=\"${_s.classNames.tagX}\" role='button' aria-label='remove tag'></x>\n            <div>\n                <span ${_s.mode === 'select' && _s.userInput ? \"contenteditable='true'\" : ''} autocapitalize=\"false\" autocorrect=\"off\" spellcheck='false' class=\"${_s.classNames.tagText}\">${tagData[_s.tagTextProp] || tagData.value}</span>\n            </div>\n        </tag>`\n    },\n\n    dropdown(settings){\n        var _sd = settings.dropdown,\n            isManual = _sd.position == 'manual';\n\n        return `<div class=\"${isManual ? '' : settings.classNames.dropdown } ${_sd.classname}\" role=\"listbox\" aria-labelledby=\"dropdown\" dir=\"${_sd.RTL ? 'rtl' : ''}\">\n                    <div data-selector='tagify-suggestions-wrapper' class=\"${settings.classNames.dropdownWrapper}\"></div>\n                </div>`\n    },\n\n    dropdownContent(HTMLContent) {\n        var _t = this.settings.templates,\n            suggestions = this.state.dropdown.suggestions;\n\n        return `\n            ${_t.dropdownHeader.call(this, suggestions)}\n            ${HTMLContent}\n            ${_t.dropdownFooter.call(this, suggestions)}\n        `\n    },\n\n    dropdownItem(item){\n        return `<div ${this.getAttributes(item)}\n                    class='${this.settings.classNames.dropdownItem} ${this.isTagDuplicate(item.value) ? this.settings.classNames.dropdownItemSelected: \"\"} ${item.class || \"\"}'\n                    tabindex=\"0\"\n                    role=\"option\">${item.mappedValue || item.value}</div>`\n    },\n\n    /**\n     * @param {Array} suggestions An array of all the matched suggested items, including those which were sliced away due to the \"dropdown.maxItems\" setting\n     */\n    dropdownHeader(suggestions){\n        return `<header data-selector='tagify-suggestions-header' class=\"${this.settings.classNames.dropdownHeader}\"></header>`\n    },\n\n    dropdownFooter(suggestions){\n        var hasMore = suggestions.length - this.settings.dropdown.maxItems;\n\n        return hasMore > 0\n            ? `<footer data-selector='tagify-suggestions-footer' class=\"${this.settings.classNames.dropdownFooter}\">\n                ${hasMore} more items. Refine your search.\n            </footer>`\n            : '';\n    },\n\n    dropdownItemNoMatch: null\n}\n", "import { decode, extend, getfirstTextNode, isChromeAndroidBrowser, isNodeTag, isWithinNodeTag, injectAtCaret, getSetTagData, fixCaretBetweenTags, placeCaretAfterNode } from './helpers'\nimport {ZERO_WIDTH_CHAR} from './constants'\n\nexport function triggerChangeEvent(){\n    if( this.settings.mixMode.integrated ) return;\n\n    var inputElm = this.DOM.originalInput,\n        changed = this.state.lastOriginalValueReported !== inputElm.value,\n        event = new CustomEvent(\"change\", {bubbles: true}); // must use \"CustomEvent\" and not \"Event\" to support IE\n\n    if( !changed ) return;\n\n    // must apply this BEFORE triggering the simulated event\n    this.state.lastOriginalValueReported = inputElm.value\n\n    // React hack: https://github.com/facebook/react/issues/11488\n    event.simulated = true\n    if (inputElm._valueTracker)\n        inputElm._valueTracker.setValue(Math.random())\n\n    inputElm.dispatchEvent(event)\n\n    // also trigger a Tagify event\n    this.trigger(\"change\", this.state.lastOriginalValueReported)\n\n    // React, for some reason, clears the input's value after \"dispatchEvent\" is fired\n    inputElm.value = this.state.lastOriginalValueReported\n}\n\nexport default {\n    // bind custom events which were passed in the settings\n    customBinding(){\n        this.customEventsList.forEach(name => {\n            this.on(name, this.settings.callbacks[name])\n        })\n    },\n\n    binding( bindUnbind = true ){\n        var _s = this.settings,\n            _CB = this.events.callbacks,\n            _CBR,\n            action = bindUnbind ? 'addEventListener' : 'removeEventListener';\n\n        // do not allow the main events to be bound more than once\n        if( (this.state.mainEvents && bindUnbind ) || _s.disabled || _s.readonly )\n            return;\n\n\n        // set the binding state of the main events, so they will not be bound more than once\n        this.state.mainEvents = bindUnbind;\n\n        // everything inside gets executed only once-per instance\n        if( bindUnbind && !this.listeners.main ){\n            this.events.bindGlobal.call(this);\n\n            if( this.settings.isJQueryPlugin )\n                jQuery(this.DOM.originalInput).on('tagify.removeAllTags', this.removeAllTags.bind(this))\n        }\n\n        // setup callback references so events could be removed later\n        _CBR = (this.listeners.main = this.listeners.main || {\n            keydown          : ['input', _CB.onKeydown.bind(this)],\n            click            : ['scope', _CB.onClickScope.bind(this)],\n            dblclick         : _s.mode != 'select' && ['scope', _CB.onDoubleClickScope.bind(this)],\n            paste            : ['input', _CB.onPaste.bind(this)],\n            drop             : ['input', _CB.onDrop.bind(this)],\n            compositionstart : ['input', _CB.onCompositionStart.bind(this)],\n            compositionend   : ['input', _CB.onCompositionEnd.bind(this)]\n        })\n\n        for( var eventName in _CBR ){\n            _CBR[eventName] && this.DOM[_CBR[eventName][0]][action](eventName, _CBR[eventName][1]);\n        }\n\n        // observers\n        var inputMutationObserver = this.listeners.main.inputMutationObserver || new MutationObserver(_CB.onInputDOMChange.bind(this));\n\n        // cleaup just-in-case\n        inputMutationObserver.disconnect()\n\n        // observe stuff\n        if( _s.mode == 'mix' ) {\n            inputMutationObserver.observe(this.DOM.input, {childList:true})\n        }\n\n        this.events.bindOriginaInputListener.call(this)\n\n        if( bindUnbind ) {\n            this.listeners.main = undefined\n        }\n    },\n\n    bindOriginaInputListener(delay) {\n        const DELAY = (delay||0) + 500\n\n        if(!this.listeners.main) return\n        // listen to original input changes (unfortunetly this is the best way...)\n        // https://stackoverflow.com/a/1949416/104380\n        clearInterval(this.listeners.main.originalInputValueObserverInterval)\n        this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), DELAY)\n    },\n\n    bindGlobal( unbind ) {\n        var _CB = this.events.callbacks,\n            action = unbind ? 'removeEventListener' : 'addEventListener',\n            e;\n\n        if( !this.listeners || (!unbind  && this.listeners.global) ) return; // do not re-bind\n\n        // these events are global and should never be unbinded, unless the instance is destroyed:\n        this.listeners.global = this.listeners.global || [\n            {\n                type: this.isIE ? 'keydown' : 'input',  // IE cannot register \"input\" events on contenteditable elements, so the \"keydown\" should be used instead..\n                target: this.DOM.input,\n                cb: _CB[this.isIE ? 'onInputIE' : 'onInput'].bind(this)\n            },\n            {\n                type: 'keydown',\n                target: window,\n                cb: _CB.onWindowKeyDown.bind(this)\n            },\n            {\n                type: 'focusin',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'focusout',\n                target: this.DOM.scope,\n                cb: _CB.onFocusBlur.bind(this)\n            },\n            {\n                type: 'click',\n                target: document,\n                cb: _CB.onClickAnywhere.bind(this),\n                useCapture: true\n            },\n        ]\n\n        for( e of this.listeners.global )\n            e.target[action](e.type, e.cb, !!e.useCapture);\n\n        if( unbind ) {\n            this.listeners.global = undefined\n        }\n    },\n\n    unbindGlobal() {\n        this.events.bindGlobal.call(this, true);\n    },\n\n    /**\n     * DOM events callbacks\n     */\n    callbacks : {\n        onFocusBlur(e){\n            // when focusing within a tag which is in edit-mode\n            var _s = this.settings,\n                nodeTag = isWithinNodeTag.call(this, e.relatedTarget),\n                targetIsTagNode = isNodeTag.call(this, e.target),\n                isTargetXBtn = e.target.classList.contains(_s.classNames.tagX),\n                isFocused = e.type == 'focusin',\n                lostFocus = e.type == 'focusout';\n\n            // when focusing within a tag which is in edit-mode, only and specifically on the text-part of the tag node\n            // and not the X button or any other custom element thatmight be there\n            // var tagTextNode = e.target?.closest(this.settings.classNames.tagTextSelector)\n\n            if(isTargetXBtn && _s.mode != 'mix' && _s.focusInputOnRemove) {\n                this.DOM.input.focus()\n            }\n\n            if( nodeTag && isFocused && (!targetIsTagNode) && !isTargetXBtn) {\n                this.toggleFocusClass(this.state.hasFocus = +new Date())\n\n                // only if focused within a tag's text node should the `onEditTagFocus` function be called.\n                // if clicked anywhere else inside a tag, which had triggered an `focusin` event,\n                // the onFocusBlur should be aborted. This part was spcifically written for `select` mode.\n                // tagTextNode && this.events.callbacks.onEditTagFocus.call(this, nodeTag)\n            }\n\n            var text = e.target ? this.trim(this.DOM.input.textContent) : '', // a string\n                currentDisplayValue = this.value?.[0]?.[_s.tagTextProp],\n                ddEnabled = _s.dropdown.enabled >= 0,\n                eventData = {relatedTarget:e.relatedTarget},\n                isTargetSelectOption = this.state.actions.selectOption && (ddEnabled || !_s.dropdown.closeOnSelect),\n                isTargetAddNewBtn = this.state.actions.addNew && ddEnabled,\n                shouldAddTags;\n\n            if( lostFocus ){\n                if( e.relatedTarget === this.DOM.scope ){\n                    this.dropdown.hide()\n                    this.DOM.input.focus()\n                    return\n                }\n\n                this.postUpdate()\n                _s.onChangeAfterBlur && this.triggerChangeEvent()\n            }\n\n            if( isTargetSelectOption || isTargetAddNewBtn || isTargetXBtn ) {\n                return;\n            }\n\n            // should only loose focus at this point if the event was not generated from within a tag\n            if( isFocused || nodeTag ) {\n                this.state.hasFocus = +new Date()\n            }\n            else {\n                this.state.hasFocus = false;\n            }\n\n            this.toggleFocusClass(this.state.hasFocus)\n\n            if( _s.mode == 'mix' ){\n                if( isFocused ){\n                    this.trigger(\"focus\", eventData)\n                }\n\n                else if( lostFocus ){\n                    this.trigger(\"blur\", eventData)\n                    this.loading(false)\n                    this.dropdown.hide()\n                    // reset state which needs reseting\n                    this.state.dropdown.visible = undefined\n                    this.setStateSelection()\n                }\n\n                return\n            }\n\n            if( isFocused ){\n                if( !_s.focusable ) return;\n\n                // if( !targetIsTagNode && _s.mode != 'select' ){\n                //     this.DOM.input.focus()\n                // }\n\n                var dropdownCanBeShown = _s.dropdown.enabled === 0 && !this.state.dropdown.visible,\n                    tagText = this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector)\n\n                this.trigger(\"focus\", eventData)\n                //  e.target.classList.remove('placeholder');\n                if( dropdownCanBeShown && !targetIsTagNode ){  // && _s.mode != \"select\"\n                    this.dropdown.show(this.value.length ? '' : undefined)\n\n                    if(_s.mode === 'select') {\n                        this.setRangeAtStartEnd(false, tagText)\n                    }\n                }\n\n                return\n            }\n\n            else if( lostFocus ){\n                this.trigger(\"blur\", eventData)\n                this.loading(false)\n\n                // when clicking the X button of a selected tag, it is unwanted for it to be added back\n                // again in a few more lines of code (shouldAddTags && addTags)\n                if( _s.mode == 'select' ) {\n                    if( this.value.length ) {\n                        let firstTagNode = this.getTagElms()[0];\n                        text = this.trim(firstTagNode.textContent)\n                    }\n\n                    // if nothing has changed (same display value), do not add a tag\n                    if( currentDisplayValue === text )\n                        text = ''\n                }\n\n                shouldAddTags = text && !this.state.actions.selectOption && _s.addTagOnBlur && _s.addTagOn.includes('blur');\n                // do not add a tag if \"selectOption\" action was just fired (this means a tag was just added from the dropdown)\n                shouldAddTags && this.addTags(text, true)\n            }\n\n            // when clicking a tag, do not consider this is a \"blur\" event\n            if ( !nodeTag )  {\n                this.DOM.input.removeAttribute('style')\n                this.dropdown.hide()\n            }\n        },\n\n        onCompositionStart(e){\n            this.state.composing = true\n        },\n\n        onCompositionEnd(e){\n            this.state.composing = false\n        },\n\n        onWindowKeyDown(e){\n            var _s = this.settings,\n                focusedElm = document.activeElement,\n                withinTag = isWithinNodeTag.call(this, focusedElm),\n                isBelong = withinTag && this.DOM.scope.contains(focusedElm),\n                isInputNode = focusedElm === this.DOM.input,\n                isReadyOnlyTag = isBelong && focusedElm.hasAttribute('readonly'),\n                tagText = this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector),\n                isDropdownVisible = this.state.dropdown.visible,\n                nextTag;\n\n            if( !(e.key === 'Tab' && isDropdownVisible) && !this.state.hasFocus && (!isBelong || isReadyOnlyTag) || isInputNode ) return;\n\n            nextTag = focusedElm.nextElementSibling;\n\n            var targetIsRemoveBtn = e.target.classList.contains(_s.classNames.tagX);\n\n            switch( e.key ){\n                // remove tag if has focus\n                case 'Backspace': {\n                    if( !_s.readonly && !this.state.editing ) {\n                        this.removeTags(focusedElm);\n                        (nextTag ? nextTag : this.DOM.input).focus()\n                    }\n\n                    break;\n                }\n\n                case 'Enter': {\n                    if( targetIsRemoveBtn ) {\n                        this.removeTags( e.target.parentNode )\n                        return\n                    }\n\n                    if( _s.a11y.focusableTags && isNodeTag.call(this, focusedElm) )\n                        setTimeout(this.editTag.bind(this), 0, focusedElm)\n\n                    break;\n                }\n\n                case 'ArrowDown' : {\n                    // if( _s.mode == 'select' ) // issue #333\n                    if( !this.state.dropdown.visible && _s.mode != 'mix' )\n                        this.dropdown.show()\n                    break;\n                }\n\n                case 'Tab': {\n                    tagText?.focus();\n                    break;\n                }\n            }\n        },\n\n        onKeydown(e){\n            var _s = this.settings;\n\n            // ignore keys during IME composition or when user input is not allowed\n            if( this.state.composing || !_s.userInput )\n                return\n\n            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length && e.key != 'Tab' ){\n                e.preventDefault()\n            }\n\n            var s = this.trim(e.target.textContent);\n\n            this.trigger(\"keydown\", {event:e})\n\n            _s.hooks.beforeKeyDown(e, {tagify:this})\n                .then(result => {\n                    /**\n                     * ONLY FOR MIX-MODE:\n                     */\n                    if( _s.mode == 'mix' ){\n                        switch( e.key ){\n                            case 'Left' :\n                            case 'ArrowLeft' : {\n                                // when left arrow was pressed, set a flag so when the dropdown is shown, right-arrow will be ignored\n                                // because it seems likely the user wishes to use the arrows to move the caret\n                                this.state.actions.ArrowLeft = true\n                                break\n                            }\n\n                            case 'Delete':\n                            case 'Backspace' : {\n                                if( this.state.editing ) return\n\n                                var sel = document.getSelection(),\n                                    deleteKeyTagDetected = e.key == 'Delete' && sel.anchorOffset == (sel.anchorNode.length || 0),\n                                    prevAnchorSibling = sel.anchorNode.previousSibling,\n                                    isCaretAfterTag = sel.anchorNode.nodeType == 1 || !sel.anchorOffset && prevAnchorSibling && prevAnchorSibling.nodeType == 1 && sel.anchorNode.previousSibling,\n                                    lastInputValue = decode(this.DOM.input.innerHTML),\n                                    lastTagElems = this.getTagElms(),\n                                    isZWS = sel.anchorNode.length === 1 && sel.anchorNode.nodeValue == String.fromCharCode(8203),\n                                    //  isCaretInsideTag = sel.anchorNode.parentNode('.' + _s.classNames.tag),\n                                    tagBeforeCaret,\n                                    tagElmToBeDeleted,\n                                    firstTextNodeBeforeTag;\n\n                                if( _s.backspace == 'edit' && isCaretAfterTag ){\n                                    tagBeforeCaret = sel.anchorNode.nodeType == 1 ? null : sel.anchorNode.previousElementSibling;\n                                    setTimeout(this.editTag.bind(this), 0, tagBeforeCaret); // timeout is needed to the last cahacrter in the edited tag won't get deleted\n                                    e.preventDefault() // needed so the tag elm won't get deleted\n                                    return;\n                                }\n\n                                if( isChromeAndroidBrowser() && isCaretAfterTag instanceof Element ){\n                                    firstTextNodeBeforeTag = getfirstTextNode(isCaretAfterTag)\n\n                                    if( !isCaretAfterTag.hasAttribute('readonly') )\n                                        isCaretAfterTag.remove() // since this is Chrome, can safetly use this \"new\" DOM API\n\n                                    // Android-Chrome wrongly hides the keyboard, and loses focus,\n                                    // so this hack below is needed to regain focus at the correct place:\n                                    this.DOM.input.focus()\n                                    setTimeout(() => {\n                                        placeCaretAfterNode(firstTextNodeBeforeTag)\n                                        this.DOM.input.click()\n\n                                    })\n\n                                    return\n                                }\n\n                                if( sel.anchorNode.nodeName == 'BR')\n                                    return\n\n                                if( (deleteKeyTagDetected || isCaretAfterTag) && sel.anchorNode.nodeType == 1 )\n                                    if( sel.anchorOffset == 0 ) // caret is at the very begining, before a tag\n                                        tagElmToBeDeleted = deleteKeyTagDetected // delete key pressed\n                                            ? lastTagElems[0]\n                                            : null;\n                                    else\n                                        tagElmToBeDeleted = lastTagElems[Math.min(lastTagElems.length, sel.anchorOffset) - 1]\n\n                                // find out if a tag *might* be a candidate for deletion, and if so, which\n                                else if( deleteKeyTagDetected )\n                                    tagElmToBeDeleted = sel.anchorNode.nextElementSibling;\n\n                                else if( isCaretAfterTag instanceof Element )\n                                    tagElmToBeDeleted = isCaretAfterTag;\n\n                                // tagElm.hasAttribute('readonly')\n                                if( sel.anchorNode.nodeType == 3 &&   // node at caret location is a Text node\n                                    !sel.anchorNode.nodeValue    &&   // has some text\n                                    sel.anchorNode.previousElementSibling )  // text node has a Tag node before it\n                                    e.preventDefault()\n\n                                // if backspace not allowed, do nothing\n                                // TODO: a better way to detect if nodes were deleted is to simply check the \"this.value\" before & after\n                                if( (isCaretAfterTag || deleteKeyTagDetected) && !_s.backspace ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && !sel.anchorOffset && sel.anchorNode == this.DOM.input && e.key != 'Delete' ){\n                                    e.preventDefault()\n                                    return\n                                }\n\n                                if( sel.type != 'Range' && tagElmToBeDeleted && tagElmToBeDeleted.hasAttribute('readonly') ){\n                                    // allows the continuation of deletion by placing the caret on the first previous textNode.\n                                    // since a few readonly-tags might be one after the other, iteration is needed:\n\n                                    placeCaretAfterNode( getfirstTextNode(tagElmToBeDeleted) )\n                                    return\n                                }\n\n                                if ( e.key == 'Delete' && isZWS && getSetTagData(sel.anchorNode.nextSibling) ) {\n                                    this.removeTags(sel.anchorNode.nextSibling)\n                                }\n\n                                // update regarding https://github.com/yairEO/tagify/issues/762#issuecomment-786464317:\n                                // the bug described is more severe than the fix below, therefore I disable the fix until a solution\n                                // is found which work well for both cases.\n                                // -------\n                                // nodeType is \"1\" only when the caret is at the end after last tag (no text after), or before first first (no text before)\n                                /*\n                                if( this.isFirefox && sel.anchorNode.nodeType == 1 && sel.anchorOffset != 0 ){\n                                    this.removeTags() // removes last tag by default if no parameter supplied\n                                    // place caret inside last textNode, if exist. it's an annoying bug only in FF,\n                                    // if the last tag is removed, and there is a textNode before it, the caret is not placed at its end\n                                    placeCaretAfterNode( setRangeAtStartEnd(false, this.DOM.input) )\n                                }\n                                */\n\n                                break;\n                            }\n                            // currently commented to allow new lines in mixed-mode\n                            case 'Enter' : {\n                                e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n\n                                // https://stackoverflow.com/a/72279112/104380\n                                let selection = window.getSelection();\n                                let range = selection.getRangeAt(0);\n                                range.insertNode(document.createElement('br'));\n                                selection.collapseToEnd();\n                            }\n                        }\n\n                        return true\n                    }\n\n                    var isManualDropdown = _s.dropdown.position == 'manual';\n\n                    switch( e.key ){\n                        case 'Backspace' :\n                            if( _s.mode == 'select' && _s.enforceWhitelist && this.value.length)\n                                this.removeTags()\n\n                            else if( !this.state.dropdown.visible || _s.dropdown.position == 'manual' ){\n                                if( e.target.textContent == \"\" || s.charCodeAt(0) == 8203 ){  // 8203: ZERO WIDTH SPACE unicode\n                                    if( _s.backspace === true )\n                                        this.removeTags()\n                                    else if( _s.backspace == 'edit' )\n                                        setTimeout(this.editTag.bind(this), 0) // timeout reason: when edited tag gets focused and the caret is placed at the end, the last character gets deletec (because of backspace)\n                                }\n                            }\n                            break;\n\n                        case 'Esc' :\n                        case 'Escape' :\n                            if( this.state.dropdown.visible ) return\n                            e.target.blur()\n                            break;\n\n                        case 'Down' :\n                        case 'ArrowDown' :\n                            // if( _s.mode == 'select' ) // issue #333\n                            if( !this.state.dropdown.visible )\n                                this.dropdown.show()\n                            break;\n\n                        case 'ArrowRight' : {\n                            let tagData = this.state.inputSuggestion || this.state.ddItemData\n                            if( tagData && _s.autoComplete.rightKey ){\n                                this.addTags([tagData], true)\n                                return;\n                            }\n                            break\n                        }\n\n                        case 'Tab' : {\n                            return true;\n                        }\n\n                        case 'Enter' :\n                            // manual suggestion boxes are assumed to always be visible\n                            if( this.state.dropdown.visible && !isManualDropdown ) return\n                            e.preventDefault(); // solves Chrome bug - http://stackoverflow.com/a/20398191/104380\n                            // because the main \"keydown\" event is bound before the dropdown events, this will fire first and will not *yet*\n                            // know if an option was just selected from the dropdown menu. If an option was selected,\n                            // the dropdown events should handle adding the tag\n\n                            var thingToAdd = this.state.autoCompleteData || s;\n\n                            setTimeout(()=>{\n                                if( (!this.state.dropdown.visible || isManualDropdown) && !this.state.actions.selectOption && _s.addTagOn.includes(e.key.toLowerCase()) ) {\n                                    this.addTags([thingToAdd], true)\n                                    this.state.autoCompleteData = null\n                                }\n                            })\n                    }\n                })\n                .catch(err => err)\n        },\n\n        onInput(e){\n            this.postUpdate() // toggles \"tagify--empty\" class\n\n            var _s = this.settings;\n\n            if( _s.mode == 'mix' )\n                return this.events.callbacks.onMixTagsInput.call(this, e);\n\n            var value = this.input.normalize.call(this, undefined, {trim: false}),\n                showSuggestions = value.length >= _s.dropdown.enabled,\n                eventData = {value, inputElm:this.DOM.input},\n                validation = this.validateTag({value});\n\n            if( _s.mode == 'select' ) {\n                this.toggleScopeValidation(validation)\n            }\n\n            eventData.isValid = validation;\n\n            // for IE; since IE doesn't have an \"input\" event so \"keyDown\" is used instead to trigger the \"onInput\" callback,\n            // and so many keys do not change the input, and for those do not continue.\n            if( this.state.inputText == value ) return;\n\n            // save the value on the input's State object\n            this.input.set.call(this, value, false); // update the input with the normalized value and run validations\n            // this.setRangeAtStartEnd(false, this.DOM.input); // fix caret position\n\n            // if delimiters detected, add tags\n            if( value.search(_s.delimiters) != -1 ){\n                if( this.addTags( value ) ){\n                    this.input.set.call(this); // clear the input field's value\n                }\n            }\n\n            else if( _s.dropdown.enabled >= 0 ){\n                this.dropdown[showSuggestions ? \"show\" : \"hide\"](value);\n            }\n\n            this.trigger('input', eventData) // \"input\" event must be triggered at this point, before the dropdown is shown\n        },\n\n        onMixTagsInput( e ){\n            var rangeText, match, matchedPatternCount, tag, showSuggestions, selection,\n                _s = this.settings,\n                lastTagsCount = this.value.length,\n                matchFlaggedTag,\n                matchDelimiters,\n                tagsElems = this.getTagElms(),\n                fragment = document.createDocumentFragment(),\n                range = window.getSelection().getRangeAt(0),\n                remainingTagsValues = [].map.call(tagsElems, node => getSetTagData(node).value);\n\n            // Android Chrome \"keydown\" event argument does not report the correct \"key\".\n            // this workaround is needed to manually call \"onKeydown\" method with a synthesized event object\n            if( e.inputType == \"deleteContentBackward\" && isChromeAndroidBrowser() ){\n                this.events.callbacks.onKeydown.call(this, {\n                    target: e.target,\n                    key: \"Backspace\",\n                })\n            }\n\n            // if there's a tag as the first child of the input, always make sure it has a zero-width character before it\n            // or if two tags are next to each-other, add a zero-space width character (For the caret to appear)\n            fixCaretBetweenTags(this.getTagElms())\n\n            // re-add \"readonly\" tags which might have been removed\n            this.value.slice().forEach(item => {\n                if( item.readonly && !remainingTagsValues.includes(item.value) )\n                    fragment.appendChild( this.createTagElem(item) )\n            })\n\n            if( fragment.childNodes.length ){\n                range.insertNode(fragment)\n                this.setRangeAtStartEnd(false, fragment.lastChild)\n            }\n\n            // check if tags were \"magically\" added/removed (browser redo/undo or CTRL-A -> delete)\n            if( tagsElems.length != lastTagsCount ){\n                this.value = [].map.call(this.getTagElms(), node => getSetTagData(node))\n                this.update({ withoutChangeEvent:true })\n                return\n            }\n\n            if( this.hasMaxTags() )\n                return true\n\n            if( window.getSelection ){\n                selection = window.getSelection()\n\n                // only detect tags if selection is inside a textNode (not somehow on already-existing tag)\n                if( selection.rangeCount > 0 && selection.anchorNode.nodeType == 3 ){\n                    range = selection.getRangeAt(0).cloneRange()\n                    range.collapse(true)\n                    range.setStart(selection.focusNode, 0)\n\n                    rangeText = range.toString().slice(0, range.endOffset)  // slice the range so everything AFTER the caret will be trimmed\n                    // split = range.toString().split(_s.mixTagsAllowedAfter)  // [\"foo\", \"bar\", \"@baz\"]\n                    matchedPatternCount = rangeText.split(_s.pattern).length - 1;\n\n                    match = rangeText.match( _s.pattern )\n\n                    if( match )\n                        // tag string, example: \"@aaa ccc\"\n                        tag = rangeText.slice( rangeText.lastIndexOf(match[match.length-1]) )\n\n                    if( tag ){\n                        this.state.actions.ArrowLeft = false // start fresh, assuming the user did not (yet) used any arrow to move the caret\n                        this.state.tag = {\n                            prefix : tag.match(_s.pattern)[0],\n                            value  : tag.replace(_s.pattern, ''), // get rid of the prefix\n                        }\n                        this.state.tag.baseOffset = selection.baseOffset - this.state.tag.value.length\n\n                        matchDelimiters = this.state.tag.value.match(_s.delimiters)\n                        // if a delimeter exists, add the value as tag (exluding the delimiter)\n                        if( matchDelimiters ){\n                            this.state.tag.value = this.state.tag.value.replace(_s.delimiters, '')\n                            this.state.tag.delimiters = matchDelimiters[0]\n                            this.addTags(this.state.tag.value, _s.dropdown.clearOnSelect)\n                            this.dropdown.hide()\n                            return\n                        }\n\n                        showSuggestions = this.state.tag.value.length >= _s.dropdown.enabled\n\n                        // When writing something that might look like a tag (an email address) but isn't one - it is unwanted\n                        // the suggestions dropdown be shown, so the user can close it (in any way), and while continue typing,\n                        // dropdown should stay closed until another tag is typed.\n                        // if( this.state.tag.value.length && this.state.dropdown.visible === false )\n                        //     showSuggestions = false\n\n                        // test for similar flagged tags to the current tag\n\n                        try{\n                            matchFlaggedTag = this.state.flaggedTags[this.state.tag.baseOffset]\n                            matchFlaggedTag = matchFlaggedTag.prefix   == this.state.tag.prefix &&\n                                              matchFlaggedTag.value[0] == this.state.tag.value[0]\n\n                            // reset\n                            if( this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value )\n                                delete this.state.flaggedTags[this.state.tag.baseOffset];\n                        }\n                        catch(err){}\n\n                        // scenario: (do not show suggestions of another matched tag, if more than one detected)\n                        // (2 tags exist)                          \" a@a.com and @\"\n                        // (second tag is removed by backspace)    \" a@a.com and \"\n                        if( matchFlaggedTag || matchedPatternCount < this.state.mixMode.matchedPatternCount )\n                            showSuggestions = false\n                    }\n                    // no (potential) tag found\n                    else{\n                        this.state.flaggedTags = {}\n                    }\n\n                    this.state.mixMode.matchedPatternCount = matchedPatternCount\n                }\n            }\n\n\n            // wait until the \"this.value\" has been updated (see \"onKeydown\" method for \"mix-mode\")\n            // the dropdown must be shown only after this event has been triggered, so an implementer could\n            // dynamically change the whitelist.\n            setTimeout(()=>{\n                this.update({withoutChangeEvent:true})\n                this.trigger('input', extend({}, this.state.tag, {textContent:this.DOM.input.textContent}))\n\n                if( this.state.tag )\n                    this.dropdown[showSuggestions ? \"show\" : \"hide\"](this.state.tag.value);\n            }, 10)\n        },\n\n        onInputIE(e){\n            var _this = this;\n            // for the \"e.target.textContent\" to be changed, the browser requires a small delay\n            setTimeout(function(){\n                _this.events.callbacks.onInput.call(_this, e)\n            })\n        },\n\n        observeOriginalInputValue(){\n            // if, for some reason, the Tagified element is no longer in the DOM,\n            // call the \"destroy\" method to kill all references to timeouts/intervals\n            if( !this.DOM.originalInput.parentNode ) this.destroy()\n\n            // if original input value changed for some reason (for exmaple a form reset)\n            if( this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue )\n                this.loadOriginalValues()\n        },\n\n        onClickAnywhere(e){\n            if (e.target != this.DOM.scope && !this.DOM.scope.contains(e.target)) {\n                this.toggleFocusClass(false)\n                this.state.hasFocus = false\n\n                let closestTagifyDropdownElem = e.target.closest(this.settings.classNames.dropdownSelector);\n\n                // do not hide the dropdown if a click was initiated within it and that dropdown belongs to this Tagify instance\n                if( closestTagifyDropdownElem?.__tagify != this )\n                    this.dropdown.hide()\n            }\n        },\n\n        onClickScope(e){\n            var _s = this.settings,\n                tagElm = e.target.closest('.' + _s.classNames.tag),\n                isScope = e.target === this.DOM.scope,\n                timeDiffFocus = +new Date() - this.state.hasFocus;\n\n            if( e.target.classList.contains(_s.classNames.tagX) ){\n                this.removeTags( e.target.parentNode )\n                return\n            }\n\n            else if( tagElm && !this.state.editing ){\n                this.trigger(\"click\", { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm), event:e })\n\n                if( _s.editTags === 1 || _s.editTags.clicks === 1 || _s.mode == 'select' )\n                    this.events.callbacks.onDoubleClickScope.call(this, e)\n\n                return\n            }\n\n            // when clicking on the input itself\n            else if( e.target == this.DOM.input ){\n                if( _s.mode == 'mix' ){\n                    // firefox won't show caret if last element is a tag (and not a textNode),\n                    // so an empty textnode should be added\n                    this.fixFirefoxLastTagNoCaret()\n                }\n\n                if( timeDiffFocus > 500 || !_s.focusable ){\n                    if( this.state.dropdown.visible )\n                        this.dropdown.hide()\n                    else if( _s.dropdown.enabled === 0 && _s.mode != 'mix' )\n                        this.dropdown.show(this.value.length ? '' : undefined)\n                    return\n                }\n            }\n\n            if( _s.mode == 'select' && _s.dropdown.enabled === 0 && !this.state.dropdown.visible) {\n                this.events.callbacks.onDoubleClickScope.call(this, {...e, target: this.getTagElms()[0]})\n\n                !_s.userInput && this.dropdown.show()\n            }\n        },\n\n        // special proccess is needed for pasted content in order to \"clean\" it\n        onPaste(e){\n            e.preventDefault()\n\n            var tagsElems,\n                _s = this.settings;\n\n            if( !_s.userInput ){\n                return false;\n            }\n\n            var clipboardData, pastedText;\n\n            if( _s.readonly ) return\n\n            // Get pasted data via clipboard API\n            clipboardData = e.clipboardData || window.clipboardData\n            pastedText = clipboardData.getData('Text')\n\n            _s.hooks.beforePaste(e, {tagify:this, pastedText, clipboardData})\n                .then(result => {\n                    if( result === undefined )\n                        result = pastedText;\n\n                    if( result ){\n                        this.injectAtCaret(result, window.getSelection().getRangeAt(0))\n\n                        if( this.settings.mode == 'mix' ){\n                            this.events.callbacks.onMixTagsInput.call(this, e);\n                        }\n\n                        else if( this.settings.pasteAsTags ){\n                            tagsElems = this.addTags(this.state.inputText + result, true)\n                        }\n\n                        else {\n                            this.state.inputText = result\n                            this.dropdown.show(result)\n                        }\n                    }\n\n                    this.trigger('paste', {event: e, pastedText, clipboardData, tagsElems})\n                })\n                .catch(err => err)\n        },\n\n        onDrop(e){\n            e.preventDefault()\n        },\n\n        onEditTagInput( editableElm, e ){\n            var tagElm = editableElm.closest('.' + this.settings.classNames.tag),\n                tagElmIdx = this.getNodeIndex(tagElm),\n                tagData = getSetTagData(tagElm),\n                textValue = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[this.settings.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                isValid = this.validateTag(dataForChangedProp), // the value could have been invalid in the first-place so make sure to re-validate it (via \"addEmptyTag\" method)\n                hasChanged = this.editTagChangeDetected(extend(tagData, dataForChangedProp));\n\n            // if the value is same as before-editing and the tag was valid before as well, ignore the  current \"isValid\" result, which is false-positive\n            if( !hasChanged && editableElm.originalIsValid === true )\n                isValid = true\n\n            tagElm.classList.toggle(this.settings.classNames.tagInvalid, isValid !== true)\n            tagData.__isValid = isValid\n\n            tagElm.title = isValid === true\n                ? tagData.title || tagData.value\n                : isValid // change the tag's title to indicate why is the tag invalid (if it's so)\n\n            // show dropdown if typed text is equal or more than the \"enabled\" dropdown setting\n            if( textValue.length >= this.settings.dropdown.enabled ){\n                // this check is needed apparently because doing browser \"undo\" will fire\n                //  \"onEditTagInput\" but \"this.state.editing\" will be \"false\"\n                if( this.state.editing )\n                    this.state.editing.value = textValue\n                this.dropdown.show(textValue)\n            }\n\n            this.trigger(\"edit:input\", {\n                tag  : tagElm,\n                index: tagElmIdx,\n                data : extend({}, this.value[tagElmIdx], {newValue:textValue}),\n                event: e\n            })\n        },\n\n        onEditTagPaste( tagElm, e ){\n            // Get pasted data via clipboard API\n            var clipboardData = e.clipboardData || window.clipboardData,\n                pastedText = clipboardData.getData('Text');\n\n            e.preventDefault()\n\n            var newNode = injectAtCaret(pastedText)\n            this.setRangeAtStartEnd(false, newNode)\n        },\n\n        onEditTagClick( tagElm, e) {\n            this.events.callbacks.onClickScope.call(this, e)\n        },\n\n        onEditTagFocus( tagElm ){\n            this.state.editing = {\n                scope: tagElm,\n                input: tagElm.querySelector(\"[contenteditable]\")\n            }\n        },\n\n        onEditTagBlur( editableElm, e ){\n            // if \"relatedTarget\" is the tag then do not continue as this should not be considered a \"blur\" event\n            var isRelatedTargetNodeTag = isNodeTag.call(this, e.relatedTarget)\n\n            // in \"select-mode\" when editing the tag's template to include more nodes other than the editable \"span\",\n            // clicking those elements should not be considered a blur event\n            if( this.settings.mode == 'select' && isRelatedTargetNodeTag && e.relatedTarget.contains(e.target) ) {\n                this.dropdown.hide()\n                return\n            }\n\n            // if \"ESC\" key was pressed then the \"editing\" state should be `false` and if so, logic should not continue\n            // because \"ESC\" reverts the edited tag back to how it was (replace the node) before editing\n            if( !this.state.editing )\n                return;\n\n            if( !this.state.hasFocus )\n                this.toggleFocusClass()\n\n            if(!this.DOM.scope.contains(document.activeElement)) {\n                this.trigger(\"blur\", {})\n            }\n\n            // one scenario is when selecting a suggestion from the dropdown, when editing, and by selecting it\n            // the \"onEditTagDone\" is called directly, already replacing the tag, so the argument \"editableElm\"\n            // node isn't in the DOM anynmore because it has been replaced.\n            if( !this.DOM.scope.contains(editableElm) ) return;\n\n            var _s           = this.settings,\n                tagElm       = editableElm.closest('.' + _s.classNames.tag),\n                tagData      = getSetTagData(tagElm),\n                textValue    = this.input.normalize.call(this, editableElm),\n                dataForChangedProp = {[_s.tagTextProp]: textValue, __tagId: tagData.__tagId}, // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                originalData = tagData.__originalData, // pre-edit data\n                hasChanged   = this.editTagChangeDetected(extend(tagData, dataForChangedProp)),\n                isValid      = this.validateTag(dataForChangedProp), // \"__tagId\" is needed so validation will skip current tag when checking for dups\n                hasMaxTags,\n                newTagData;\n\n            if( !textValue ){\n                this.onEditTagDone(tagElm)\n                return\n            }\n\n            // if nothing changed revert back to how it was before editing\n            if( !hasChanged ){\n                this.onEditTagDone(tagElm, originalData)\n                return\n            }\n\n            // need to know this because if \"keepInvalidTags\" setting is \"true\" and an invalid tag is edited as a valid one,\n            // but the maximum number of tags have alreay been reached, so it should not allow saving the new valid value.\n            // only if the tag was already valid before editing, ignore this check (see a few lines below)\n            hasMaxTags = this.hasMaxTags()\n\n            newTagData = extend(\n                {},\n                originalData,\n                {\n                    [_s.tagTextProp]: this.trim(textValue),\n                    __isValid: isValid\n                }\n            )\n\n            // pass through optional transformer defined in settings\n            _s.transformTag.call(this, newTagData, originalData)\n\n            // MUST re-validate after tag transformation\n            // only validate the \"tagTextProp\" because is the only thing that metters for validating an edited tag.\n            // -- Scenarios: --\n            // 1. max 3 tags allowd. there are 4 tags, one has invalid input and is edited to a valid one, and now should be marked as \"not allowed\" because limit of tags has reached\n            // 2. max 3 tags allowed. there are 3 tags, one is edited, and so max-tags vaildation should be OK\n            isValid = (!hasMaxTags || originalData.__isValid === true) && this.validateTag(newTagData)\n\n            if( isValid !== true ){\n                this.trigger(\"invalid\", { data:newTagData, tag:tagElm, message:isValid })\n\n                // do nothing if invalid, stay in edit-mode until corrected or reverted by presssing esc\n                if( _s.editTags.keepInvalid ) return\n\n                if( _s.keepInvalidTags )\n                    newTagData.__isValid = isValid\n                else\n                    // revert back if not specified to keep\n                    newTagData = originalData\n            }\n\n            else if( _s.keepInvalidTags ){\n                // cleaup any previous leftovers if the tag was invalid\n                delete newTagData.title\n                delete newTagData[\"aria-invalid\"]\n                delete newTagData.class\n            }\n\n            // tagElm.classList.toggle(_s.classNames.tagInvalid, true)\n\n            this.onEditTagDone(tagElm, newTagData)\n        },\n\n        onEditTagkeydown(e, tagElm){\n            // ignore keys during IME composition\n            if( this.state.composing )\n                return\n\n            this.trigger(\"edit:keydown\", {event:e})\n\n            switch( e.key ){\n                case 'Esc' :\n                case 'Escape' : {\n                    this.state.editing = false\n                    var hasValueToRevertTo = !!tagElm.__tagifyTagData.__originalData.value\n\n                    if( hasValueToRevertTo )\n                        // revert the tag to how it was before editing\n                        // replace current tag with original one (pre-edited one)\n                        tagElm.parentNode.replaceChild(tagElm.__tagifyTagData.__originalHTML, tagElm)\n                    else\n                        tagElm.remove()\n\n                    break\n                }\n                case 'Enter' :\n                case 'Tab' : {\n                    e.preventDefault()\n\n                    var EDITED_TAG_BLUR_DELAY = 0;\n\n                    // a setTimeout is used so when editing (in \"select\" mode) while the dropdown is shown and a suggestion is highlighted\n                    // and ENTER key is pressed down - the `dropdown.hide` method won't be invoked immediately and unbind the dropdown's\n                    // KEYDOWN \"ENTER\" before it has time to call the handler and select the suggestion.\n                    setTimeout(() => e.target.blur(), EDITED_TAG_BLUR_DELAY)\n                }\n            }\n        },\n\n        onDoubleClickScope(e){\n            var tagElm = e.target.closest('.' + this.settings.classNames.tag);\n\n            if( !tagElm ) return\n\n            var tagData = getSetTagData(tagElm),\n                _s = this.settings,\n                isEditingTag,\n                isReadyOnlyTag;\n\n            if( tagData?.editable === false ) return\n\n            isEditingTag = tagElm.classList.contains(this.settings.classNames.tagEditing)\n            isReadyOnlyTag = tagElm.hasAttribute('readonly')\n\n            if( !_s.readonly && !isEditingTag && !isReadyOnlyTag && this.settings.editTags && _s.userInput ) {\n                this.events.callbacks.onEditTagFocus.call(this, tagElm)\n                this.editTag(tagElm)\n            }\n\n            this.toggleFocusClass(true)\n\n            if( _s.mode != 'select' )\n                this.trigger('dblclick', { tag:tagElm, index:this.getNodeIndex(tagElm), data:getSetTagData(tagElm) })\n        },\n\n        /**\n         *\n         * @param {Object} m an object representing the observed DOM changes\n         */\n        onInputDOMChange(m){\n            // iterate all DOM mutation\n            m.forEach(record => {\n                // only the ADDED nodes\n                record.addedNodes.forEach(addedNode => {\n                    // fix chrome's placing '<div><br></div>' everytime ENTER key is pressed, and replace with just `<br'\n                    if( addedNode.outerHTML == '<div><br></div>' ){\n                        addedNode.replaceWith(document.createElement('br'))\n                    }\n\n                    // if the added element is a div containing a tag within it (chrome does this when pressing ENTER before a tag)\n                    else if( addedNode.nodeType == 1 && addedNode.querySelector(this.settings.classNames.tagSelector) ){\n                        let newlineText = document.createTextNode('')\n\n                        if( addedNode.childNodes[0].nodeType == 3 && addedNode.previousSibling.nodeName != 'BR' )\n                            newlineText  = document.createTextNode('\\n')\n\n                        // unwrap the useless div\n                        // chrome adds a BR at the end which should be removed\n                        addedNode.replaceWith(...[newlineText, ...[...addedNode.childNodes].slice(0,-1)])\n                        placeCaretAfterNode(newlineText)\n                    }\n\n                    // if this is a tag\n                    else if( isNodeTag.call(this, addedNode) ){\n                        if( addedNode.previousSibling?.nodeType == 3 && !addedNode.previousSibling.textContent )\n                            addedNode.previousSibling.remove()\n\n                        // and it is the first node in a new line\n                        if( addedNode.previousSibling && addedNode.previousSibling.nodeName == 'BR' ){\n                            // allows placing the caret just before the tag, when the tag is the first node in that line\n                            addedNode.previousSibling.replaceWith('\\n' + ZERO_WIDTH_CHAR)\n\n                            let nextNode = addedNode.nextSibling, anythingAfterNode = '';\n\n                            while (nextNode) {\n                                anythingAfterNode += nextNode.textContent\n                                nextNode = nextNode.nextSibling;\n                            }\n\n                            // when hitting ENTER for new line just before an existing tag, but skip below logic when a tag has been addded\n                            anythingAfterNode.trim() && placeCaretAfterNode(addedNode.previousSibling)\n                        }\n\n                        // if previous sibling does not exists (meanning the addedNode is the first node in this.DOM.input)\n                        // or, if the previous sibling is also a tag, add a zero-space character before (to allow showing the caret in Chrome)\n                        else if( !addedNode.previousSibling || getSetTagData(addedNode.previousSibling) ){\n                            addedNode.before(ZERO_WIDTH_CHAR)\n                        }\n                    }\n                })\n\n                record.removedNodes.forEach(removedNode => {\n                    // when trying to delete a tag which is in a new line and there's nothing else there (caret is after the tag)\n                    if( removedNode && removedNode.nodeName == 'BR' && isNodeTag.call(this, lastInputChild)){\n                        this.removeTags(lastInputChild)\n                        this.fixFirefoxLastTagNoCaret()\n                    }\n                })\n            })\n\n            // get the last child only after the above DOM modifications\n            // check these scenarios:\n            // 1. after a single line, press ENTER once - should add only 1 BR\n            // 2. presss ENTER right before a tag\n            // 3. press enter within a text node before a tag\n            var lastInputChild = this.DOM.input.lastChild;\n\n            if( lastInputChild && lastInputChild.nodeValue == '' )\n                lastInputChild.remove()\n\n            // make sure the last element is always a BR\n            if( !lastInputChild || lastInputChild.nodeName != 'BR' ){\n                this.DOM.input.appendChild(document.createElement('br'))\n            }\n        },\n    }\n}\n\n", "import { sameStr, removeCollectionProp, omit, isObject, parseHTML, removeTextChildNodes, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag, injectAtCaret, placeCaretAfterNode, getSetTagData, fixCaretBetweenTags, logger } from './parts/helpers'\nimport DEFAULTS from './parts/defaults'\nimport _dropdown, { initDropdown } from './parts/dropdown'\nimport { getPersistedData, setPersistedData, clearPersistedData } from './parts/persist'\nimport TEXTS from './parts/texts'\nimport templates from './parts/templates'\nimport EventDispatcher from './parts/EventDispatcher'\nimport events, { triggerChangeEvent } from './parts/events'\nimport { UPDATE_DELAY } from './parts/constants'\n\n/**\n * @constructor\n * @param {Object} input    DOM element\n * @param {Object} settings settings object\n */\nfunction Tagify( input, settings ){\n    if( !input ){\n        logger.warn('input element not found', input)\n        // return an empty mock of all methods, so the code using tagify will not break\n        // because it might be calling methods even though the input element does not exist\n        const mockInstance = new Proxy(this, { get(){ return () => mockInstance } })\n        return mockInstance\n    }\n\n    if( input.__tagify ){\n        logger.warn('input element is already Tagified - Same instance is returned.', input)\n        return input.__tagify\n    }\n\n    extend(this, EventDispatcher(this))\n    this.isFirefox = (/firefox|fxios/i).test(navigator.userAgent) && !(/seamonkey/i).test(navigator.userAgent)\n    this.isIE = window.document.documentMode; // https://developer.mozilla.org/en-US/docs/Web/API/Document/compatMode#Browser_compatibility\n\n    settings = settings || {};\n    this.getPersistedData = getPersistedData(settings.id)\n    this.setPersistedData = setPersistedData(settings.id)\n    this.clearPersistedData = clearPersistedData(settings.id)\n    this.applySettings(input, settings)\n\n    this.state = {\n        inputText: '',\n        editing : false,\n        composing: false,\n        actions : {},   // UI actions for state-locking\n        mixMode : {},\n        dropdown: {},\n        flaggedTags: {} // in mix-mode, when a string is detetced as potential tag, and the user has chocen to close the suggestions dropdown, keep the record of the tasg here\n    }\n\n    this.value = [] // tags' data\n\n    // events' callbacks references will be stores here, so events could be unbinded\n    this.listeners = {}\n\n    this.DOM = {} // Store all relevant DOM elements in an Object\n\n    this.build(input)\n    initDropdown.call(this)\n\n    this.getCSSVars()\n    this.loadOriginalValues()\n\n    this.events.customBinding.call(this)\n    this.events.binding.call(this)\n    input.autofocus && this.DOM.input.focus()\n    input.__tagify = this\n}\n\nTagify.prototype = {\n    _dropdown,\n    placeCaretAfterNode,\n    getSetTagData,\n    helpers: {sameStr, removeCollectionProp, omit, isObject, parseHTML, escapeHTML, extend, concatWithoutDups, getUID, isNodeTag},\n\n    customEventsList : ['change', 'add', 'remove', 'invalid', 'input', 'paste', 'click', 'keydown', 'focus', 'blur', 'edit:input', 'edit:beforeUpdate', 'edit:updated', 'edit:start', 'edit:keydown', 'dropdown:show', 'dropdown:hide', 'dropdown:select', 'dropdown:updated', 'dropdown:noMatch', 'dropdown:scroll'],\n    dataProps: ['__isValid', '__removed', '__originalData', '__originalHTML', '__tagId'], // internal-uasge props\n\n    trim(text){\n        return this.settings.trim && text && typeof text == \"string\" ? text.trim() : text\n    },\n\n    // expose this handy utility function\n    parseHTML,\n\n    templates,\n\n    parseTemplate(template, data){\n        template = this.settings.templates[template] || template;\n        return parseHTML( template.apply(this, data) )\n    },\n\n    set whitelist( arr ){\n        const isArray = arr && Array.isArray(arr)\n        this.settings.whitelist = isArray ? arr : []\n        this.setPersistedData(isArray ? arr : [], 'whitelist')\n    },\n\n    get whitelist(){\n        return this.settings.whitelist\n    },\n\n    set userInput( state ){\n        this.settings.userInput = !!state\n        this.setContentEditable(!!state)\n    },\n\n    get userInput(){\n        return this.settings.userInput\n    },\n\n    generateClassSelectors(classNames){\n        for( let name in classNames ) {\n            let currentName = name;\n            Object.defineProperty(classNames, currentName + \"Selector\" , {\n                get(){ return \".\" + this[currentName].split(\" \")[0] }\n            })\n        }\n    },\n\n    applySettings( input, settings ){\n        DEFAULTS.templates = this.templates\n\n        var mixModeDefaults = {\n            dropdown: {\n                position: \"text\"\n            }\n        }\n\n        var mergedDefaults = extend({}, DEFAULTS, (settings.mode == 'mix' ? mixModeDefaults : {}));\n        var _s = this.settings = extend({}, mergedDefaults, settings)\n\n        _s.disabled = input.hasAttribute('disabled')\n        _s.readonly = _s.readonly || input.hasAttribute('readonly')\n        _s.placeholder = escapeHTML(input.getAttribute('placeholder') || _s.placeholder || \"\")\n        _s.required = input.hasAttribute('required')\n\n        this.generateClassSelectors(_s.classNames)\n\n        if( this.isIE )\n            _s.autoComplete = false; // IE goes crazy if this isn't false\n\n        [\"whitelist\", \"blacklist\"].forEach(name => {\n            var attrVal = input.getAttribute('data-' + name)\n            if( attrVal ){\n                attrVal = attrVal.split(_s.delimiters)\n                if( attrVal instanceof Array )\n                    _s[name] = attrVal\n            }\n        })\n\n        // backward-compatibility for old version of \"autoComplete\" setting:\n        if( \"autoComplete\" in settings && !isObject(settings.autoComplete) ){\n            _s.autoComplete = DEFAULTS.autoComplete\n            _s.autoComplete.enabled = settings.autoComplete\n        }\n\n        if( _s.mode == 'mix' ){\n            _s.pattern = _s.pattern || /@/;\n            _s.autoComplete.rightKey = true\n            _s.delimiters = settings.delimiters || null // default dlimiters in mix-mode must be NULL\n\n            // needed for \"filterListItems\". This assumes the user might have forgotten to manually\n            // define the same term in \"dropdown.searchKeys\" as defined in \"tagTextProp\" setting, so\n            // by automatically adding it, tagify is \"helping\" out, guessing the intesntions of the developer.\n            if( _s.tagTextProp && !_s.dropdown.searchKeys.includes(_s.tagTextProp) )\n                _s.dropdown.searchKeys.push(_s.tagTextProp)\n        }\n\n        if( input.pattern )\n            try { _s.pattern = new RegExp(input.pattern)  }\n            catch(e){}\n\n        // Convert the \"delimiters\" setting into a REGEX object\n        if( _s.delimiters ){\n            _s._delimiters = _s.delimiters;\n            try { _s.delimiters = new RegExp(this.settings.delimiters, \"g\") }\n            catch(e){}\n        }\n\n        if( _s.disabled || _s.readonly )\n            _s.userInput = false;\n\n        this.TEXTS = {...TEXTS, ...(_s.texts || {})}\n\n        // it makes sense to enable \"includeSelectedTags\" in \"select-mode\"\n        if( _s.mode == 'select' ){\n            _s.dropdown.includeSelectedTags = true\n        }\n\n        // make sure the dropdown will be shown on \"focus\" and not only after typing something (in \"select\" mode)\n        if( (_s.mode == 'select' && !settings.dropdown?.enabled) || !_s.userInput ){\n            _s.dropdown.enabled = 0\n        }\n\n        // additional override\n        if( _s.disabled ) {\n            _s.dropdown.enabled = false;\n        }\n\n        _s.dropdown.appendTarget = settings.dropdown?.appendTarget || document.body;\n\n        if ( _s.dropdown.includeSelectedTags === undefined )\n            _s.dropdown.includeSelectedTags = _s.duplicates;\n\n        // get & merge persisted data with current data\n        let persistedWhitelist = this.getPersistedData('whitelist');\n\n        if( Array.isArray(persistedWhitelist))\n            this.whitelist = Array.isArray(_s.whitelist)\n                ? concatWithoutDups(_s.whitelist, persistedWhitelist)\n                : persistedWhitelist;\n    },\n\n    /**\n     * Returns a string of HTML element attributes\n     * @param {Object} data [Tag data]\n     */\n    getAttributes( data ){\n        var attrs = this.getCustomAttributes(data), s = '', k;\n\n        for( k in attrs )\n            s += \" \" + k + (data[k] !== undefined ? `=\"${attrs[k]}\"` : \"\");\n\n        return s;\n    },\n\n    /**\n     * Returns an object of attributes to be used for the templates\n     */\n    getCustomAttributes( data ){\n        // only items which are objects have properties which can be used as attributes\n        if( !isObject(data) )\n            return '';\n\n        var output = {}, propName;\n\n        for( propName in data ){\n            if( propName.slice(0,2) != '__' && propName != 'class' && data.hasOwnProperty(propName) && data[propName] !== undefined )\n                output[propName] = escapeHTML(data[propName])\n        }\n        return output\n    },\n\n    setStateSelection(){\n        var selection = window.getSelection()\n\n        // save last selection place to be able to inject anything from outside to that specific place\n        var sel = {\n            anchorOffset: selection.anchorOffset,\n            anchorNode  : selection.anchorNode,\n            range       : selection.getRangeAt && selection.rangeCount && selection.getRangeAt(0)\n        }\n\n        this.state.selection = sel\n        return sel\n    },\n\n    /**\n     * Get specific CSS variables which are relevant to this script and parse them as needed.\n     * The result is saved on the instance in \"this.CSSVars\"\n     */\n    getCSSVars(){\n        var compStyle = getComputedStyle(this.DOM.scope, null)\n\n        const getProp = name => compStyle.getPropertyValue('--'+name)\n\n        function seprateUnitFromValue(a){\n            if( !a ) return {}\n            a = a.trim().split(' ')[0]\n            var unit  = a.split(/\\d+/g).filter(n=>n).pop().trim(),\n                value = +a.split(unit).filter(n=>n)[0].trim()\n            return {value, unit}\n        }\n\n        this.CSSVars = {\n            tagHideTransition: (({value, unit}) => unit=='s' ? value * 1000 : value)(seprateUnitFromValue(getProp('tag-hide-transition')))\n        }\n    },\n\n    /**\n     * builds the HTML of this component\n     * @param  {Object} input [DOM element which would be \"transformed\" into \"Tags\"]\n     */\n    build( input ){\n        var DOM  = this.DOM,\n            labelWrapper = input.closest('label');\n\n        if( this.settings.mixMode.integrated ){\n            DOM.originalInput = null;\n            DOM.scope = input;\n            DOM.input = input;\n        }\n\n        else {\n            DOM.originalInput = input\n            DOM.originalInput_tabIndex = input.tabIndex\n            DOM.scope = this.parseTemplate('wrapper', [input, this.settings])\n            DOM.input = DOM.scope.querySelector(this.settings.classNames.inputSelector)\n            input.parentNode.insertBefore(DOM.scope, input)\n            input.tabIndex = -1; // do not allow focus or typing directly, once tagified\n        }\n\n        // fixes tagify nested inside a <label> tag from getting focus when clicked on\n        if( labelWrapper )\n            labelWrapper.setAttribute('for', '')\n    },\n\n    /**\n     * revert any changes made by this component\n     */\n    destroy(){\n        this.events.unbindGlobal.call(this)\n        this.DOM.scope.parentNode?.removeChild(this.DOM.scope)\n        this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex\n        delete this.DOM.originalInput.__tagify\n        this.dropdown.hide(true)\n        this.removeAllCustomListeners()\n        clearTimeout(this.dropdownHide__bindEventsTimeout)\n        clearInterval(this.listeners?.main?.originalInputValueObserverInterval)\n    },\n\n    /**\n     * if the original input has any values, add them as tags\n     */\n    loadOriginalValues( value ){\n        var lastChild,\n            _s = this.settings\n\n        // temporarily block firing the \"change\" event on the original input until\n        // this method finish removing current value and adding a new one\n        this.state.blockChangeEvent = true\n\n        if( value === undefined ){\n            const persistedOriginalValue = this.getPersistedData('value')\n\n            // if the field already has a field, trust its the desired\n            // one to be rendered and do not use the persisted one\n            if( persistedOriginalValue && !this.DOM.originalInput.value )\n                value = persistedOriginalValue\n            else\n                value = _s.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value\n        }\n\n        this.removeAllTags()\n\n        if( value ){\n            if( _s.mode == 'mix' ){\n                this.parseMixTags(value)\n\n                lastChild = this.DOM.input.lastChild\n\n                // fixes a Chrome bug, when the last node in `mix-mode` is a tag, the caret appears at the far-top-top, outside the field\n                if( !lastChild || lastChild.tagName != 'BR' )\n                    this.DOM.input.insertAdjacentHTML('beforeend', '<br>')\n            }\n\n            else{\n                try{\n                    if( JSON.parse(value) instanceof Array )\n                        value = JSON.parse(value)\n                }\n                catch(err){}\n                this.addTags(value, true).forEach(tag => tag && tag.classList.add(_s.classNames.tagNoAnimation))\n            }\n        }\n\n        else\n            this.postUpdate()\n\n        this.state.lastOriginalValueReported = _s.mixMode.integrated ? '' : this.DOM.originalInput.value\n    },\n\n    cloneEvent(e){\n        var clonedEvent = {}\n        for( var v in e )\n            if( v != 'path' )\n                clonedEvent[v] = e[v]\n        return clonedEvent\n    },\n\n    /**\n     * Toogle global loading state on/off\n     * Useful when fetching async whitelist while user is typing\n     * @param {Boolean} isLoading\n     */\n    loading( isLoading ){\n        this.state.isLoading = isLoading\n        // IE11 doesn't support toggle with second parameter\n        this.DOM.scope.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.scopeLoading)\n        return this\n    },\n\n    /**\n     * Toogle a tag loading state on/off\n     * @param {Boolean} isLoading\n     */\n    tagLoading( tagElm, isLoading ){\n        if( tagElm )\n            // IE11 doesn't support toggle with second parameter\n            tagElm.classList[isLoading ? \"add\" : \"remove\"](this.settings.classNames.tagLoading)\n        return this\n    },\n\n    /**\n     * Toggles class on the main tagify container (\"scope\")\n     * @param {String} className\n     * @param {Boolean} force\n     */\n    toggleClass( className, force ){\n        if( typeof className == 'string' )\n            this.DOM.scope.classList.toggle(className, force)\n    },\n\n    toggleScopeValidation( validation ){\n        var isValid = validation === true || validation === undefined; // initially it is undefined\n\n        if( !this.settings.required && validation && validation === this.TEXTS.empty)\n            isValid = true\n\n        this.toggleClass(this.settings.classNames.tagInvalid, !isValid)\n        this.DOM.scope.title = isValid ? '' : validation\n    },\n\n    toggleFocusClass( force ){\n        this.toggleClass(this.settings.classNames.focus, !!force)\n    },\n\n    /**\n     * Sets the templates placeholder after initialization\n     * @param {String} str\n     */\n    setPlaceholder(str) {\n        ['data', 'aria'].forEach(p => this.DOM.input.setAttribute(`${p}-placeholder`, str))\n    },\n\n    triggerChangeEvent,\n\n    events,\n\n    fixFirefoxLastTagNoCaret(){\n        return // seems to be fixed in newer version of FF, so retiring below code (for now)\n        // var inputElm = this.DOM.input\n\n        // if( this.isFirefox && inputElm.childNodes.length && inputElm.lastChild.nodeType == 1 ){\n        //     inputElm.appendChild(document.createTextNode(\"\\u200b\"))\n        //     this.setRangeAtStartEnd(true, inputElm)\n        //     return true\n        // }\n    },\n\n    /** https://stackoverflow.com/a/59156872/104380\n     * @param {Boolean} start indicating where to place it (start or end of the node)\n     * @param {Object}  node  DOM node to place the caret at\n     */\n    setRangeAtStartEnd( start, node ){\n        if( !node ) return;\n\n        start = typeof start == 'number' ? start : !!start\n        node = node.lastChild || node;\n        var sel = document.getSelection()\n\n        // do not force caret placement if the current selection (focus) is on another element (not this tagify instance)\n        if( sel.focusNode instanceof Element && !this.DOM.input.contains(sel.focusNode) ) {\n            return true\n        }\n\n        try{\n            if( sel.rangeCount >= 1 ){\n                ['Start', 'End'].forEach(pos =>\n                    sel.getRangeAt(0)[\"set\" + pos](node, start ? start : node.length)\n                )\n            }\n        } catch(err){\n            console.warn(err)\n        }\n    },\n\n    insertAfterTag( tagElm, newNode ){\n        newNode = newNode || this.settings.mixMode.insertAfterTag;\n\n        if( !tagElm || !tagElm.parentNode || !newNode ) return\n\n        newNode = typeof newNode == 'string'\n            ? document.createTextNode(newNode)\n            : newNode\n\n        tagElm.parentNode.insertBefore(newNode, tagElm.nextSibling)\n        return newNode\n    },\n\n    // compares all \"__originalData\" property values with the current \"tagData\" properties\n    // and returns \"true\" if something changed.\n    editTagChangeDetected(tagData) {\n        var originalData = tagData.__originalData;\n\n        for( var prop in originalData )\n            if( !this.dataProps.includes(prop) && tagData[prop] != originalData[prop] )\n                return true\n\n        return false; // not changed\n    },\n\n    // returns the node which has the actual tag's content\n    getTagTextNode(tagElm){\n        return tagElm.querySelector(this.settings.classNames.tagTextSelector)\n    },\n\n    // sets the text of a tag\n    setTagTextNode(tagElm, HTML){\n        this.getTagTextNode(tagElm).innerHTML = escapeHTML(HTML)\n    },\n\n    /**\n     * Enters a tag into \"edit\" mode\n     * @param {Node} tagElm the tag element to edit. if nothing specified, use last last\n     */\n    editTag( tagElm, opts ){\n        tagElm = tagElm || this.getLastTag()\n        opts = opts || {}\n\n        var _s = this.settings,\n            editableElm = this.getTagTextNode(tagElm),\n            tagIdx = this.getNodeIndex(tagElm),\n            tagData = getSetTagData(tagElm),\n            _CB = this.events.callbacks,\n            isValid = true,\n            isSelectMode = _s.mode == 'select'\n\n        // select mode is a bit different as clicking the tagify's content once will get into edit-mode if a value\n        // is already selected, and there cannot be a dropdown already open at this point.\n        !isSelectMode && this.dropdown.hide()\n\n        if( !editableElm ){\n            logger.warn('Cannot find element in Tag template: .', _s.classNames.tagTextSelector);\n            return;\n        }\n\n        if( tagData instanceof Object && \"editable\" in tagData && !tagData.editable )\n            return\n\n        // cache the original data, on the DOM node, before any modification ocurs, for possible revert\n        tagData = getSetTagData(tagElm, {\n            __originalData: extend({}, tagData),\n            __originalHTML: tagElm.cloneNode(true)\n        })\n        // re-set the tagify custom-prop on the clones element (because cloning removed it)\n        getSetTagData(tagData.__originalHTML, tagData.__originalData)\n\n        editableElm.setAttribute('contenteditable', true)\n        tagElm.classList.add( _s.classNames.tagEditing )\n\n        // because \"editTag\" method can be called manually, make sure that \"state.editing\" is set correctly\n        this.events.callbacks.onEditTagFocus.call(this, tagElm)\n\n        editableElm.addEventListener('click'            , _CB.onEditTagClick.bind(this, tagElm))\n        editableElm.addEventListener('blur'             , _CB.onEditTagBlur.bind(this, this.getTagTextNode(tagElm)))\n        editableElm.addEventListener('input'            , _CB.onEditTagInput.bind(this, editableElm))\n        editableElm.addEventListener('paste'            , _CB.onEditTagPaste.bind(this, editableElm))\n        editableElm.addEventListener('keydown'          , e => _CB.onEditTagkeydown.call(this, e, tagElm))\n        editableElm.addEventListener('compositionstart' , _CB.onCompositionStart.bind(this))\n        editableElm.addEventListener('compositionend'   , _CB.onCompositionEnd.bind(this))\n\n        if( !opts.skipValidation )\n            isValid = this.editTagToggleValidity(tagElm)\n\n        editableElm.originalIsValid = isValid\n\n        this.trigger(\"edit:start\", { tag:tagElm, index:tagIdx, data:tagData, isValid })\n\n        editableElm.focus()\n        !isSelectMode && this.setRangeAtStartEnd(false, editableElm) // place the caret at the END of the editable tag text\n\n        _s.dropdown.enabled === 0 && !isSelectMode && this.dropdown.show()\n        this.state.hasFocus = true\n\n        return this\n    },\n\n    /**\n     * If a tag is invalid, for any reason, set its class to \"not allowed\" (see defaults file)\n     * @param {Node} tagElm required\n     * @param {Object} tagData optional\n     * @returns true if valid, a string (reason) if not\n     */\n    editTagToggleValidity( tagElm, tagData ){\n        var tagData = tagData || getSetTagData(tagElm),\n            isValid;\n\n        if( !tagData ){\n            logger.warn(\"tag has no data: \", tagElm, tagData)\n            return;\n        }\n\n        isValid = !(\"__isValid\" in tagData) || tagData.__isValid === true\n\n        if( !isValid ){\n            this.removeTagsFromValue(tagElm)\n        }\n\n        this.update()\n\n        //this.validateTag(tagData);\n\n        tagElm.classList.toggle(this.settings.classNames.tagNotAllowed, !isValid)\n        tagData.__isValid = isValid;\n\n        return tagData.__isValid\n    },\n\n    onEditTagDone(tagElm, tagData){\n        tagElm = tagElm || this.state.editing.scope\n        tagData = tagData || {}\n\n        var _s = this.settings,\n            eventData = {\n                tag         : tagElm,\n                index       : this.getNodeIndex(tagElm),\n                previousData: getSetTagData(tagElm),\n                data        : tagData\n            }\n\n        this.trigger(\"edit:beforeUpdate\", eventData, {cloneData:false})\n\n        this.state.editing = false;\n\n        delete tagData.__originalData\n        delete tagData.__originalHTML\n\n        // some scenarrios like in the one in the demos page with textarea that has 2 whitelists, one of the whitelist might be\n        // an array of objects with a property defined the same as the `tagTextProp` setting (if used) but another whitelist\n        // might be simpler - just an array of primitives.\n        function veryfyTagTextProp() {\n            var tagTextProp = tagData[_s.tagTextProp];\n\n            // 'tagTextProp' might also be the number 0 so checking for `undefined` here:\n            if( tagTextProp !== undefined ) {\n                tagTextProp += ''; // cast possible number into a string\n                return !!tagTextProp.trim?.()\n            }\n\n            if( !(_s.tagTextProp in tagData) )\n                return !!tagData.value\n        }\n\n        if( tagElm && tagElm.parentNode ){\n            if( veryfyTagTextProp() ){\n                tagElm = this.replaceTag(tagElm, tagData)\n                this.editTagToggleValidity(tagElm, tagData)\n\n                if( _s.a11y.focusableTags )\n                    tagElm.focus()\n                else if( _s.mode != 'select' )\n                    // place caret after edited tag\n                    placeCaretAfterNode(tagElm)\n            }\n\n            else\n                this.removeTags(tagElm)\n        }\n\n        this.trigger(\"edit:updated\", eventData)\n        _s.dropdown.closeOnSelect && this.dropdown.hide()\n\n        // check if any of the current tags which might have been marked as \"duplicate\" should be now un-marked\n        if( this.settings.keepInvalidTags )\n            this.reCheckInvalidTags()\n    },\n\n    /**\n     * Replaces an exisitng tag with a new one. Used for updating a tag's data\n     * @param {Object} tagElm  [DOM node to replace]\n     * @param {Object} tagData [data to create new tag from]\n     */\n    replaceTag(tagElm, tagData){\n        if( !tagData || tagData.value === '' || tagData.value === undefined )\n            tagData = tagElm.__tagifyTagData\n\n        // if tag is invalid, make the according changes in the newly created element\n        if( tagData.__isValid && tagData.__isValid != true )\n            extend( tagData, this.getInvalidTagAttrs(tagData, tagData.__isValid) )\n\n        var newTagElm = this.createTagElem(tagData)\n\n        // update DOM\n        tagElm.parentNode.replaceChild(newTagElm, tagElm)\n        this.updateValueByDOMTags()\n        return newTagElm\n    },\n\n    /**\n     * update \"value\" (Array of Objects) by traversing all valid tags\n     */\n    updateValueByDOMTags(){\n        this.value.length = 0;\n\n        var clsNames = this.settings.classNames,\n            tagNotAllowedClassName = clsNames.tagNotAllowed.split(' ')[0],\n            skipNodesWithClassNames = [tagNotAllowedClassName, clsNames.tagHide];\n\n        [].forEach.call(this.getTagElms(), node => {\n            if ([...node.classList].some(cls => skipNodesWithClassNames.includes(cls))) return;\n            this.value.push( getSetTagData(node) )\n        })\n\n        this.update()\n        this.dropdown.refilter()\n    },\n\n    /**\n     * injects nodes/text at caret position, which is saved on the \"state\" when \"blur\" event gets triggered\n     * @param {Node} injectedNode [the node to inject at the caret position]\n     * @param {Object} selection [optional range Object. must have \"anchorNode\" & \"anchorOffset\"]\n     */\n    injectAtCaret( injectedNode, range ){\n        range = range || this.state.selection?.range\n\n        if(typeof injectedNode === 'string')\n            injectedNode = document.createTextNode(injectedNode)\n\n        if( !range && injectedNode ) {\n            this.appendMixTags(injectedNode)\n            return this;\n        }\n\n        const isValidInjectionPoint = this.DOM.scope.contains(range?.startContainer)\n\n        if (!isValidInjectionPoint) {\n            return this;\n        }\n\n        let node = injectAtCaret(injectedNode, range)\n        this.setRangeAtStartEnd(false, node)\n\n        this.updateValueByDOMTags() // updates internal \"this.value\"\n        this.update() // updates original input/textarea\n\n        return this\n    },\n\n    /**\n     * input bridge for accessing & setting\n     * @type {Object}\n     */\n    input : {\n        set( value = '', updateDOM = true ){\n            var _s = this.settings,\n                hideDropdown = _s.dropdown.closeOnSelect\n\n            this.state.inputText = value\n\n            if( updateDOM ) {\n                this.DOM.input.innerHTML = escapeHTML(\"\"+value);\n                value && this.toggleClass(_s.classNames.empty, !this.DOM.input.innerHTML) // remove the \"empty\" (is exists) class only if a value was added\n            }\n\n            if( !value && hideDropdown )\n                this.dropdown.hide.bind(this)\n\n            this.input.autocomplete.suggest.call(this);\n            this.input.validate.call(this);\n\n        },\n\n        raw(){\n            return this.DOM.input.textContent\n        },\n\n        /**\n         * Marks the tagify's input as \"invalid\" if the value did not pass \"validateTag()\"\n         */\n        validate(){\n            var isValid = !this.state.inputText || this.validateTag({value:this.state.inputText}) === true;\n\n            this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !isValid)\n\n            return isValid\n        },\n\n        // remove any child DOM elements that aren't of type TEXT (like <br>)\n        normalize( node, options ){\n            var clone = node || this.DOM.input, //.cloneNode(true),\n                v = [];\n\n            // when a text was pasted in FF, the \"this.DOM.input\" element will have <br> but no newline symbols (\\n), and this will\n            // result in tags not being properly created if one wishes to create a separate tag per newline.\n            clone.childNodes.forEach(n => n.nodeType==3 && v.push(n.nodeValue))\n            v = v.join(\"\\n\")\n\n            try{\n                // \"delimiters\" might be of a non-regex value, where this will fail (\"Tags With Properties\" example in demo page):\n                v = v.replace(/(?:\\r\\n|\\r|\\n)/g, this.settings.delimiters.source.charAt(0))\n            }\n            catch(err){}\n\n            v = v.replace(/\\s/g, ' ')  // replace NBSPs with spaces characters\n\n            return options?.trim ? this.trim(v) : v\n        },\n\n        /**\n         * suggest the rest of the input's value (via CSS \"::after\" using \"content:attr(...)\")\n         * @param  {String} s [description]\n         */\n        autocomplete : {\n            suggest( data ){\n                if( !this.settings.autoComplete.enabled ) return;\n\n                data = data || {value:''}\n                if (typeof data !== 'object') data = { value: data };\n\n                var suggestedText = this.dropdown.getMappedValue(data);\n\n                if( typeof suggestedText === 'number' ) return\n\n                var inputText = this.state.inputText.toLowerCase(),\n                    suggestionStart = suggestedText.substr(0, this.state.inputText.length).toLowerCase(),\n                    suggestionTrimmed = suggestedText.substring(this.state.inputText.length);\n\n                if( !suggestedText || !this.state.inputText || suggestionStart != inputText ){\n                    this.DOM.input.removeAttribute(\"data-suggest\");\n                    delete this.state.inputSuggestion\n                }\n                else{\n                    this.DOM.input.setAttribute(\"data-suggest\", suggestionTrimmed);\n                    this.state.inputSuggestion = data\n                }\n            },\n\n            /**\n             * sets the suggested text as the input's value & cleanup the suggestion autocomplete.\n             * @param {String} s [text]\n             */\n            set( s ){\n                var dataSuggest = this.DOM.input.getAttribute('data-suggest'),\n                    suggestion = s || (dataSuggest ? this.state.inputText + dataSuggest : null);\n\n                if( suggestion ){\n                    if( this.settings.mode == 'mix' ){\n                        this.replaceTextWithNode( document.createTextNode(this.state.tag.prefix + suggestion) )\n                    }\n                    else{\n                        this.input.set.call(this, suggestion);\n                        this.setRangeAtStartEnd(false, this.DOM.input)\n                    }\n\n                    this.input.autocomplete.suggest.call(this);\n                    this.dropdown.hide();\n\n                    return true;\n                }\n\n                return false;\n            }\n        }\n    },\n\n    /**\n     * returns the index of the the tagData within the \"this.value\" array collection.\n     * since values should be unique, it is suffice to only search by \"value\" property\n     * @param {Object} tagData\n     */\n    getTagIdx( tagData ){\n        return this.value.findIndex(item => item.__tagId == (tagData||{}).__tagId )\n    },\n\n    getNodeIndex( node ){\n        var index = 0;\n\n        if( node )\n            while( (node = node.previousElementSibling) )\n                index++;\n\n        return index;\n    },\n\n    getTagElms( ...classess ){\n        var classname = '.' + [...this.settings.classNames.tag.split(' '), ...classess].join('.')\n        return [].slice.call(this.DOM.scope.querySelectorAll(classname)) // convert nodeList to Array - https://stackoverflow.com/a/3199627/104380\n    },\n\n    /**\n     * gets the last non-readonly, not-in-the-proccess-of-removal tag\n     */\n    getLastTag(){\n        var _sc = this.settings.classNames,\n            tagNodes = this.DOM.scope.querySelectorAll(`${_sc.tagSelector}:not(.${_sc.tagHide}):not([readonly])`);\n        return tagNodes[tagNodes.length - 1];\n    },\n\n    /**\n     * Searches if any tag with a certain value already exis\n     * @param  {String/Object} value [text value / tag data object]\n     * @param  {Boolean} caseSensitive\n     * @return {Number}\n     */\n    isTagDuplicate( value, caseSensitive, tagId ){\n        var dupsCount = 0;\n\n        for( let item of this.value ) {\n            let isSameStr = sameStr( this.trim(\"\"+value), item.value, caseSensitive );\n            if( isSameStr && tagId != item.__tagId )\n                dupsCount++;\n        }\n\n        return dupsCount\n    },\n\n    getTagIndexByValue( value ){\n        var indices = [],\n            isCaseSensitive = this.settings.dropdown.caseSensitive;\n\n        this.getTagElms().forEach((tagElm, i) => {\n            if(  tagElm.__tagifyTagData && sameStr( this.trim(tagElm.__tagifyTagData.value), value, isCaseSensitive )  )\n                indices.push(i)\n        })\n\n        return indices;\n    },\n\n    getTagElmByValue( value ){\n        var tagIdx = this.getTagIndexByValue(value)[0]\n        return this.getTagElms()[tagIdx]\n    },\n\n    /**\n     * Temporarily marks a tag element (by value or Node argument)\n     * @param  {Object} tagElm [a specific \"tag\" element to compare to the other tag elements siblings]\n     */\n    flashTag( tagElm ){\n        if( tagElm ){\n            tagElm.classList.add(this.settings.classNames.tagFlash)\n            setTimeout(() => { tagElm.classList.remove(this.settings.classNames.tagFlash) }, 100)\n        }\n    },\n\n    /**\n     * checks if text is in the blacklist\n     */\n    isTagBlacklisted( v ){\n        v = this.trim(v.toLowerCase());\n        return this.settings.blacklist.filter(x => (\"\"+x).toLowerCase() == v).length;\n    },\n\n    /**\n     * checks if text is in the whitelist\n     */\n    isTagWhitelisted( v ){\n        return !!this.getWhitelistItem(v)\n        /*\n        return this.settings.whitelist.some(item =>\n            typeof v == 'string'\n                ? sameStr(this.trim(v), (item.value || item))\n                : sameStr(JSON.stringify(item), JSON.stringify(v))\n        )\n        */\n    },\n\n    /**\n     * Returns the first whitelist item matched, by value (if match found)\n     * @param {String} value [text to match by]\n     */\n    getWhitelistItem( value, prop, whitelist ){\n        var result,\n            prop = prop || 'value',\n            _s = this.settings,\n            whitelist = whitelist || _s.whitelist;\n\n        whitelist.some(_wi => {\n            // whitelist item value. Can be either a String, Number or an Object (with a `value` property)\n            var _wiv = typeof _wi == 'object' ? (_wi[prop] || _wi.value) : _wi,\n                isSameStr = sameStr(_wiv, value, _s.dropdown.caseSensitive, _s.trim)\n\n            if( isSameStr ){\n                result = typeof _wi == 'object' ? _wi : {value:_wi}\n                return true\n            }\n        })\n\n        // first iterate the whitelist, try find matches by \"value\" and if that fails\n        // and a \"tagTextProp\" is set to be other than \"value\", try that also\n        if( !result && prop == 'value' && _s.tagTextProp != 'value' ){\n            // if found, adds the first which matches\n            result = this.getWhitelistItem(value, _s.tagTextProp, whitelist)\n        }\n\n        return result\n    },\n\n    /**\n     * validate a tag object BEFORE the actual tag will be created & appeneded\n     * @param  {String} s\n     * @param  {String} uid      [unique ID, to not inclue own tag when cheking for duplicates]\n     * @return {Boolean/String}  [\"true\" if validation has passed, String for a fail]\n     */\n    validateTag( tagData ){\n        var _s = this.settings,\n            // when validating a tag in edit-mode, need to take \"tagTextProp\" into consideration\n            prop = \"value\" in tagData ? \"value\" : _s.tagTextProp,\n            v = this.trim(tagData[prop] + \"\");\n\n        // check for definitive empty value\n        if( !(tagData[prop]+\"\").trim() )\n            return this.TEXTS.empty;\n\n        // check if pattern should be used and if so, use it to test the value\n        if( _s.mode != 'mix' && _s.pattern && _s.pattern instanceof RegExp && !(_s.pattern.test(v)) )\n            return this.TEXTS.pattern;\n\n        // check for duplicates\n        if( !_s.duplicates && this.isTagDuplicate(v, _s.dropdown.caseSensitive, tagData.__tagId) )\n            return this.TEXTS.duplicate;\n\n        if( this.isTagBlacklisted(v) || (_s.enforceWhitelist && !this.isTagWhitelisted(v)) )\n            return this.TEXTS.notAllowed;\n\n        if( _s.validate )\n            return _s.validate(tagData)\n\n        return true\n    },\n\n    getInvalidTagAttrs(tagData, validation){\n        return {\n            \"aria-invalid\" : true,\n            \"class\": `${tagData.class || ''} ${this.settings.classNames.tagNotAllowed}`.trim(),\n            \"title\": validation\n        }\n    },\n\n    hasMaxTags(){\n        return this.value.length >= this.settings.maxTags\n            ? this.TEXTS.exceed\n            : false\n    },\n\n    setReadonly( toggle, attrribute ){\n        var _s = this.settings\n\n        this.DOM.scope.contains(document.activeElement) && document.activeElement.blur() // exit possible edit-mode\n        _s[attrribute || 'readonly'] = toggle\n        this.DOM.scope[(toggle ? 'set' : 'remove') + 'Attribute'](attrribute || 'readonly', true)\n\n        this.settings.userInput = true;\n        this.setContentEditable(!toggle)\n\n        if( !toggle ) {\n            // first unbind all events\n            this.events.binding.call(this, true)\n            // re-bind all events\n            this.events.binding.call(this)\n        }\n    },\n\n    setContentEditable(state){\n        this.DOM.scope.querySelectorAll(\"[data-can-editable]\").forEach(elm => {\n            elm.contentEditable = state\n            elm.tabIndex = !!state ? 0 : -1;\n        })\n    },\n\n    setDisabled( isDisabled ){\n        this.setReadonly(isDisabled, 'disabled')\n    },\n\n    /**\n     * pre-proccess the tagsItems, which can be a complex tagsItems like an Array of Objects or a string comprised of multiple words\n     * so each item should be iterated on and a tag created for.\n     * @return {Array} [Array of Objects]\n     */\n    normalizeTags( tagsItems ){\n        var {whitelist, delimiters, mode, tagTextProp} = this.settings,\n            whitelistMatches = [],\n            whitelistWithProps = whitelist ? whitelist[0] instanceof Object : false,\n            // checks if this is a \"collection\", meanning an Array of Objects\n            isArray = Array.isArray(tagsItems),\n            isCollection = isArray && tagsItems[0].value,\n            mapStringToCollection = s => (s+\"\").split(delimiters).reduce((acc, v) => {\n                const trimmed = this.trim(v)\n                trimmed && acc.push({ [tagTextProp]:trimmed, value:trimmed })\n                return acc\n            }, [])\n\n        if( typeof tagsItems == 'number' )\n            tagsItems = tagsItems.toString()\n\n        // if the argument is a \"simple\" String, ex: \"aaa, bbb, ccc\"\n        if( typeof tagsItems == 'string' ){\n            if( !tagsItems.trim() ) return [];\n\n            // go over each tag and add it (if there were multiple ones)\n            tagsItems = mapStringToCollection(tagsItems)\n        }\n\n        // if is an Array of Strings, convert to an Array of Objects\n        else if( isArray ){\n            // flatten the 2D array\n            tagsItems = tagsItems.reduce((acc, item) => {\n                if( isObject(item) ) {\n                    var itemCopy = extend({}, item)\n\n                    // if 'tagTextProp' property does not exist in the item, use `value` instead\n                    if(!(tagTextProp in itemCopy))\n                        tagTextProp = 'value'\n\n                    itemCopy[tagTextProp] = this.trim(itemCopy[tagTextProp])\n\n                    // discard empty tags but allow `0` as a valid value\n                    if( itemCopy[tagTextProp] || itemCopy[tagTextProp] === 0 )\n                        acc.push(itemCopy) // mapStringToCollection(item.value).map(newItem => ({...item,...newItem}))\n                }\n\n                else if(item != null && item !== '' && item !== undefined) {\n                    acc.push( ...mapStringToCollection(item) )\n                }\n\n                return acc\n            }, [])\n        }\n\n        // search if the tag exists in the whitelist as an Object (has props),\n        // to be able to use its properties.\n        // skip matching collections with whitelist items as they are considered \"whole\"\n        if( whitelistWithProps && !isCollection ){\n            tagsItems.forEach(item => {\n                var whitelistMatchesValues = whitelistMatches.map(a=>a.value)\n\n                // if suggestions are shown, they are already filtered, so it's easier to use them,\n                // because the whitelist might also include items which have already been added\n                var filteredList = this.dropdown.filterListItems.call(this, item[tagTextProp], { exact:true })\n\n                if( !this.settings.duplicates )\n                    // also filter out items which have already been matched in previous iterations\n                    filteredList = filteredList.filter(filteredItem => !whitelistMatchesValues.includes(filteredItem.value))\n\n                // get the best match out of list of possible matches.\n                // if there was a single item in the filtered list, use that one\n                var matchObj = filteredList.length > 1\n                    ? this.getWhitelistItem(item[tagTextProp], tagTextProp, filteredList)\n                    : filteredList[0]\n\n                if( matchObj && matchObj instanceof Object ){\n                    whitelistMatches.push( matchObj ) // set the Array (with the found Object) as the new value\n                }\n                else if( mode != 'mix' ){\n                    if( item.value == undefined )\n                        item.value = item[tagTextProp]\n                    whitelistMatches.push(item)\n                }\n            })\n\n            if( whitelistMatches.length )\n                tagsItems = whitelistMatches\n        }\n\n        return tagsItems;\n    },\n\n    /**\n     * Parse the initial value of a textarea (or input) element and generate mixed text w/ tags\n     * https://stackoverflow.com/a/57598892/104380\n     * @param {String} s\n     */\n    parseMixTags( s ){\n        var {mixTagsInterpolator, duplicates, transformTag, enforceWhitelist, maxTags, tagTextProp} = this.settings,\n            tagsDataSet = [];\n\n        s = s.split(mixTagsInterpolator[0]).map((s1, i) => {\n            var s2 = s1.split(mixTagsInterpolator[1]),\n                preInterpolated = s2[0],\n                maxTagsReached = tagsDataSet.length == maxTags,\n                textProp,\n                tagData,\n                tagElm;\n\n            try{\n                // skip numbers and go straight to the \"catch\" statement\n                if( preInterpolated == +preInterpolated )\n                    throw Error\n                tagData = JSON.parse(preInterpolated)\n            } catch(err){\n                tagData = this.normalizeTags(preInterpolated)[0] || {value:preInterpolated}\n            }\n\n            transformTag.call(this, tagData)\n\n            if( !maxTagsReached   &&\n                s2.length > 1   &&\n                (!enforceWhitelist || this.isTagWhitelisted(tagData.value))   &&\n                !(!duplicates && this.isTagDuplicate(tagData.value)) ){\n\n                // in case \"tagTextProp\" setting is set to other than \"value\" and this tag does not have this prop\n                textProp = tagData[tagTextProp] ? tagTextProp : 'value'\n                tagData[textProp] = this.trim(tagData[textProp])\n\n                tagElm = this.createTagElem(tagData)\n                tagsDataSet.push( tagData )\n                tagElm.classList.add(this.settings.classNames.tagNoAnimation)\n\n                s2[0] = tagElm.outerHTML //+ \"&#8288;\"  // put a zero-space at the end so the caret won't jump back to the start (when the last input's child element is a tag)\n                this.value.push(tagData)\n            }\n            else if(s1)\n                return i ? mixTagsInterpolator[0] + s1 : s1\n\n            return s2.join('')\n        }).join('')\n\n        this.DOM.input.innerHTML = s\n        this.DOM.input.appendChild(document.createTextNode(''))\n        this.DOM.input.normalize()\n\n        var tagNodes = this.getTagElms()\n\n        tagNodes.forEach((elm, idx) => getSetTagData(elm,  tagsDataSet[idx]))\n        this.update({withoutChangeEvent:true})\n\n        fixCaretBetweenTags(tagNodes, this.state.hasFocus)\n        return s\n    },\n\n    /**\n     * For mixed-mode: replaces a text starting with a prefix with a wrapper element (tag or something)\n     * First there *has* to be a \"this.state.tag\" which is a string that was just typed and is staring with a prefix\n     */\n    replaceTextWithNode( newWrapperNode, strToReplace ){\n        if( !this.state.tag && !strToReplace ) return;\n\n        strToReplace = strToReplace || this.state.tag.prefix + this.state.tag.value;\n        var idx, nodeToReplace,\n            selection = this.state.selection || window.getSelection(),\n            nodeAtCaret = selection.anchorNode,\n            firstSplitOffset = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;\n\n        // STEP 1: ex. replace #ba with the tag \"bart\" where \"|\" is where the caret is:\n        // CURRENT STATE: \"foo #ba #ba| #ba\"\n\n        // split the text node at the index of the caret\n        nodeAtCaret.splitText(selection.anchorOffset - firstSplitOffset)\n\n        // node 0: \"foo #ba #ba|\"\n        // node 1: \" #ba\"\n\n        // get index of LAST occurence of \"#ba\"\n        idx = nodeAtCaret.nodeValue.lastIndexOf(strToReplace)\n\n        if( idx == -1 ) return true;\n\n        nodeToReplace = nodeAtCaret.splitText(idx)\n\n        // node 0: \"foo #ba \"\n        // node 1: \"#ba\"    <- nodeToReplace\n\n        newWrapperNode && nodeAtCaret.parentNode.replaceChild(newWrapperNode, nodeToReplace)\n\n        // must NOT normalize contenteditable or it will cause unwanted issues:\n        // https://monosnap.com/file/ZDVmRvq5upYkidiFedvrwzSswegWk7\n        // nodeAtCaret.parentNode.normalize()\n\n        return true;\n    },\n\n    /**\n     * Validate a tag's data and create a new tag node\n     * @param {*} tagData\n     * @param {*} options\n     * @returns Object\n     */\n    prepareNewTagNode(tagData, options) {\n        options = options || {}\n\n        var tagElm,\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            tagElmParams = {},\n            originalData = Object.assign({}, tagData, {value:tagData.value+\"\"});\n\n        // shallow-clone tagData so later modifications will not apply to the source\n        tagData = Object.assign({}, originalData)\n        _s.transformTag.call(this, tagData)\n\n        tagData.__isValid = this.hasMaxTags() || this.validateTag(tagData)\n\n        if( tagData.__isValid !== true ){\n            if( options.skipInvalid )\n                return\n\n            // originalData is kept because it might be that this tag is invalid because it is a duplicate of another,\n            // and if that other tags is edited/deleted, this one should be re-validated and if is no more a duplicate - restored\n            extend(tagElmParams, this.getInvalidTagAttrs(tagData, tagData.__isValid), {__preInvalidData:originalData})\n\n            if( tagData.__isValid == this.TEXTS.duplicate )\n                // mark, for a brief moment, the tag (this this one) which THIS CURRENT tag is a duplcate of\n                this.flashTag( this.getTagElmByValue(tagData.value) )\n\n            if( !_s.createInvalidTags ){\n                aggregatedInvalidInput.push(tagData.value)\n                return\n            }\n        }\n\n        if( 'readonly' in tagData ){\n            if( tagData.readonly )\n                tagElmParams[\"aria-readonly\"] = true\n            // if \"readonly\" is \"false\", remove it from the tagData so it won't be added as an attribute in the template\n            else\n                delete tagData.readonly\n        }\n\n        // Create tag HTML element\n        tagElm = this.createTagElem(tagData, tagElmParams)\n\n        return {tagElm, tagData, aggregatedInvalidInput}\n    },\n\n    /**\n     * Logic to happen once a tag has just been injected into the DOM\n     * @param {Node} tagElm\n     * @param {Object} tagData\n     */\n    postProcessNewTagNode(tagElm, tagData) {\n        var _s = this.settings,\n            isValid = tagData.__isValid;\n\n        if( isValid && isValid === true ){\n            // update state\n            this.value.push(tagData)\n        }\n        else{\n            this.trigger('invalid', {data:tagData, index:this.value.length, tag:tagElm, message:isValid})\n            if( !_s.keepInvalidTags )\n                // remove invalid tags (if \"keepInvalidTags\" is set to \"false\")\n                setTimeout(() => this.removeTags(tagElm, true), 1000)\n        }\n\n        this.dropdown.position() // reposition the dropdown because the just-added tag might cause a new-line\n    },\n\n    /**\n     * For selecting a single option (not used for multiple tags, but for \"mode:select\" only)\n     * @param {Object} tagElm   Tag DOM node\n     * @param {Object} tagData  Tag data\n     */\n    selectTag( tagElm, tagData ){\n        var _s = this.settings\n\n        if( _s.enforceWhitelist && !this.isTagWhitelisted(tagData.value) )\n            return\n\n        // this.input.set.call(this, tagData[_s.tagTextProp] || tagData.value, true)\n\n        // place the caret at the end of the input, only if a dropdown option was selected (and not by manually typing another value and clicking \"TAB\")\n        if( this.state.actions.selectOption )\n            setTimeout(() => this.setRangeAtStartEnd(false, this.DOM.input))\n\n        var lastTagElm = this.getLastTag()\n\n        if( lastTagElm )\n            this.replaceTag(lastTagElm, tagData)\n        else\n            this.appendTag(tagElm)\n\n        // if( _s.enforceWhitelist )\n        //     this.setContentEditable(false);\n\n        this.value[0] = tagData\n        this.update()\n        this.trigger('add', { tag:tagElm, data:tagData })\n\n        return [tagElm]\n    },\n\n    /**\n     * add an empty \"tag\" element in an editable state\n     */\n    addEmptyTag( initialData ){\n        var tagData = extend({ value:\"\" }, initialData || {}),\n            tagElm = this.createTagElem(tagData)\n\n        getSetTagData(tagElm, tagData)\n\n        // add the tag to the component's DOM\n        this.appendTag(tagElm)\n        this.editTag(tagElm, {skipValidation:true})\n        this.toggleFocusClass(true)\n    },\n\n    /**\n     * add a \"tag\" element to the \"tags\" component\n     * @param {String/Array} tagsItems   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     * @param {Boolean}      clearInput  [flag if the input's value should be cleared after adding tags]\n     * @param {Boolean}      skipInvalid [do not add, mark & remove invalid tags]\n     * @return {Array} Array of DOM elements (tags)\n     */\n    addTags( tagsItems, clearInput, skipInvalid ){\n        var tagElems = [],\n            _s = this.settings,\n            aggregatedInvalidInput = [],\n            frag = document.createDocumentFragment(),\n            addedTags = []; // all tags, also invalid. this is used for firing the `add` event\n\n        if( !tagsItems || tagsItems.length == 0 ){\n            return tagElems\n        }\n\n        // converts Array/String/Object to an Array of Objects\n        tagsItems = this.normalizeTags(tagsItems)\n\n        switch( _s.mode ){\n            case 'mix': return this.addMixTags(tagsItems)\n            case 'select': {\n                clearInput = false\n                this.removeAllTags()\n            }\n        }\n\n        this.DOM.input.removeAttribute('style')\n\n        tagsItems.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData, {skipInvalid: skipInvalid || _s.skipInvalid});\n\n            if( !newTagNode) return;\n\n            const tagElm = newTagNode.tagElm;\n\n            tagData = newTagNode.tagData\n            aggregatedInvalidInput = newTagNode.aggregatedInvalidInput\n\n            tagElems.push(tagElm)\n\n            // mode-select overrides\n            if( _s.mode == 'select' ){\n                return this.selectTag(tagElm, tagData)\n            }\n\n            // add the tag to the component's DOM\n            // this.appendTag(tagElm)\n            frag.appendChild(tagElm)\n            this.postProcessNewTagNode(tagElm, tagData)\n            addedTags.push({tagElm, tagData})\n        })\n\n        this.appendTag(frag)\n\n        addedTags.forEach(({tagElm, tagData}) =>\n            this.trigger('add', {tag:tagElm, index:this.getTagIdx(tagData), data:tagData})\n        )\n\n        this.update()\n\n\n        if( tagsItems.length && clearInput ){\n            this.input.set.call(this, _s.createInvalidTags ? '' : aggregatedInvalidInput.join(_s._delimiters))\n            this.setRangeAtStartEnd(false, this.DOM.input)\n        }\n\n        // hydrate the suggestions list\n        this.dropdown.refilter()\n        return tagElems\n    },\n\n    /**\n     * Adds a mix-content tag\n     * @param {String/Array} tagData    A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings\n     */\n    addMixTags( tagsData ){\n        tagsData = this.normalizeTags(tagsData);\n\n        // flow for creating custom tags which aren't a part of the whitelist\n        if( tagsData[0].prefix || this.state.tag ){\n            return this.prefixedTextToTag(tagsData[0])\n        }\n\n        var frag = document.createDocumentFragment()\n\n        tagsData.forEach(tagData => {\n            const newTagNode = this.prepareNewTagNode(tagData)\n            frag.appendChild(newTagNode.tagElm)\n            this.insertAfterTag(newTagNode.tagElm)\n            this.postProcessNewTagNode(newTagNode.tagElm, newTagNode.tagData)\n        })\n\n        this.appendMixTags(frag)\n\n        return frag.children\n    },\n\n    appendMixTags( node ) {\n        var selection = !!this.state.selection;\n\n        // if \"selection\" exists, assumes intention of inecting the new tag at the last\n        // saved location of the caret inside \"this.DOM.input\"\n        if( selection ){\n            this.injectAtCaret(node)\n        }\n        // else, create a range and inject the new tag as the last child of \"this.DOM.input\"\n        else{\n            this.DOM.input.focus()\n            selection = this.setStateSelection()\n            selection.range.setStart(this.DOM.input, selection.range.endOffset)\n            selection.range.setEnd(this.DOM.input, selection.range.endOffset)\n            this.DOM.input.appendChild(node)\n\n            this.updateValueByDOMTags() // updates internal \"this.value\"\n            this.update() // updates original input/textarea\n        }\n    },\n\n    /**\n     * Adds a tag which was activly typed by the user\n     * @param {String/Array} tagData   [A string (single or multiple values with a delimiter), or an Array of Objects or just Array of Strings]\n     */\n    prefixedTextToTag( tagData ){\n        var _s = this.settings,\n            tagElm,\n            newTag,\n            createdFromDelimiters = this.state.tag?.delimiters;\n\n        tagData.prefix = tagData.prefix || this.state.tag ? this.state.tag.prefix : (_s.pattern.source||_s.pattern)[0];\n\n        newTag = this.prepareNewTagNode(tagData)\n        tagElm = newTag.tagElm\n\n        // tries to replace a taged textNode with a tagElm, and if not able,\n        // insert the new tag to the END if \"addTags\" was called from outside\n        if( !this.replaceTextWithNode(tagElm) ){\n            this.DOM.input.appendChild(tagElm)\n        }\n\n        setTimeout(()=> tagElm.classList.add(this.settings.classNames.tagNoAnimation), 300)\n\n        this.update()\n\n        if( !createdFromDelimiters ) {\n            var elm = this.insertAfterTag(tagElm) || tagElm;\n            // a timeout is needed when selecting a tag from the suggestions via mouse.\n            // Without it, it seems the caret is placed right after the tag and not after the\n            // node which was inserted after the tag (whitespace by default)\n            setTimeout(placeCaretAfterNode, 0, elm);\n        }\n\n        this.state.tag = null\n\n        this.postProcessNewTagNode(tagElm, newTag.tagData)\n\n        return tagElm\n    },\n\n    /**\n     * appened (validated) tag to the component's DOM scope\n     */\n    appendTag(tagElm){\n        var DOM = this.DOM,\n            insertBeforeNode = DOM.input;\n\n        //if( insertBeforeNode === DOM.input )\n            DOM.scope.insertBefore(tagElm, insertBeforeNode)\n        //else\n        //    DOM.scope.appendChild(tagElm)\n    },\n\n    /**\n     * creates a DOM tag element and injects it into the component (this.DOM.scope)\n     * @param  {Object}  tagData [text value & properties for the created tag]\n     * @param  {Object}  extraData [properties which are for the HTML template only]\n     * @return {Object} [DOM element]\n     */\n    createTagElem( tagData, extraData ){\n        tagData.__tagId = getUID()\n\n        var tagElm,\n            templateData = extend({}, tagData, { value:escapeHTML(tagData.value+\"\"), ...extraData });\n\n        // if( this.settings.readonly )\n        //     tagData.readonly = true\n\n        tagElm = this.parseTemplate('tag', [templateData, this])\n\n        // crucial for proper caret placement when deleting content. if textNodes are allowed as children of a tag element,\n        // a browser bug casues the caret to be misplaced inside the tag element (especially affects \"readonly\" tags)\n        removeTextChildNodes(tagElm)\n        // while( tagElm.lastChild.nodeType == 3 )\n        //     tagElm.lastChild.parentNode.removeChild(tagElm.lastChild)\n\n        getSetTagData(tagElm, tagData)\n        return tagElm\n    },\n\n    /**\n     * re-check all invalid tags.\n     * called after a tag was edited or removed\n     */\n    reCheckInvalidTags(){\n        var _s = this.settings\n\n        this.getTagElms(_s.classNames.tagNotAllowed).forEach((tagElm, i) => {\n            var tagData = getSetTagData(tagElm),\n                hasMaxTags = this.hasMaxTags(),\n                tagValidation = this.validateTag(tagData),\n                isValid = tagValidation === true && !hasMaxTags;\n\n            if( _s.mode == 'select' )\n                this.toggleScopeValidation(tagValidation)\n\n            // if the tag has become valid\n            if( isValid ){\n                tagData = tagData.__preInvalidData\n                    ? tagData.__preInvalidData\n                    : { value:tagData.value }\n\n                return this.replaceTag(tagElm, tagData)\n            }\n\n            // if the tag is still invaild, set its title as such (reson of invalid might have changed)\n            tagElm.title = hasMaxTags || tagValidation\n        })\n    },\n\n    /**\n     * Removes a tag\n     * @param  {Array|Node|String}  tagElms         [DOM element(s) or a String value. if undefined or null, remove last added tag]\n     * @param  {Boolean}            silent          [A flag, which when turned on, does not remove any value and does not update the original input value but simply removes the tag from tagify]\n     * @param  {Number}             tranDuration    [Transition duration in MS]\n     * TODO: Allow multiple tags to be removed at-once\n     */\n    removeTags( tagElms, silent, tranDuration ){\n        var tagsToRemove,\n            _s = this.settings;\n\n        tagElms = tagElms && tagElms instanceof HTMLElement\n            ? [tagElms]\n            : tagElms instanceof Array\n                ? tagElms\n                : tagElms\n                    ? [tagElms]\n                    : [this.getLastTag()].filter(n => n)   // must filter because \"this.getLastTag()\" might be `undefined` if there are not tags\n\n        // normalize tagElms array values:\n        // 1. removing invalid items\n        // 2, if an item is String try to get the matching Tag HTML node\n        // 3. get the tag data\n        // 4. return a collection of Objects\n        tagsToRemove = tagElms.reduce((elms, tagElm) => {\n            if( tagElm && typeof tagElm == 'string')\n                tagElm = this.getTagElmByValue(tagElm)\n\n            var tagData = getSetTagData(tagElm);\n\n            if( tagElm && tagData && !tagData.readonly ) // make sure it's a tag and not some other node\n                // because the DOM node might be removed by async animation, the state will be updated while\n                // the node might still be in the DOM, so the \"update\" method should know which nodes to ignore\n                elms.push({\n                    node: tagElm,\n                    idx: this.getTagIdx(tagData), // this.getNodeIndex(tagElm); // this.getTagIndexByValue(tagElm.textContent)\n                    data: getSetTagData(tagElm, {'__removed':true})\n                })\n\n            return elms\n        }, [])\n\n        tranDuration = typeof tranDuration == \"number\" ? tranDuration : this.CSSVars.tagHideTransition\n\n        if( _s.mode == 'select' ){\n            tranDuration = 0;\n            this.input.set.call(this)\n        }\n\n        // if only a single tag is to be removed.\n        // skip \"select\" mode because invalid tags are actually set to `this.value`\n        if( tagsToRemove.length == 1 && _s.mode != 'select' ){\n            if( tagsToRemove[0].node.classList.contains(_s.classNames.tagNotAllowed) )\n                silent = true\n        }\n\n        if( !tagsToRemove.length )\n            return;\n\n        return _s.hooks.beforeRemoveTag(tagsToRemove, {tagify:this})\n            .then(() => {\n                function removeNode( tag ){\n                    if( !tag.node.parentNode ) return\n\n                    tag.node.parentNode.removeChild(tag.node)\n\n                    if( !silent ){\n                        // this.removeValueById(tagData.__uid)\n                        this.dropdown.refilter()\n                        this.dropdown.position()\n                        this.DOM.input.normalize() // best-practice when in mix-mode (safe to do always anyways)\n\n                        // check if any of the current tags which might have been marked as \"duplicate\" should be un-marked\n                        if( _s.keepInvalidTags )\n                            this.reCheckInvalidTags()\n\n                        // below code is unfinished. it should iterate all currently invalid edited tags, which their edits have not\n                        // changed the value yet, and should re-trigger the check, but since nothing has changed, it does not work...\n                        // this.getTagElms(_s.classNames.tagEditing).forEach( this.events.callbacks.onEditTagBlur.bind )\n\n                            this.trigger('remove', { tag:tag.node, index:tag.idx, data:tag.data })\n                    }\n                    else if( _s.keepInvalidTags )\n                            this.trigger('remove', { tag:tag.node, index:tag.idx })\n                }\n\n                function animation( tag ){\n                    tag.node.style.width = parseFloat(window.getComputedStyle(tag.node).width) + 'px'\n                    document.body.clientTop // force repaint for the width to take affect before the \"hide\" class below\n                    tag.node.classList.add(_s.classNames.tagHide)\n\n                    // manual timeout (hack, since transitionend cannot be used because of hover)\n                    setTimeout(removeNode.bind(this), tranDuration, tag)\n                }\n\n                // update state regardless of animation\n                if( !silent ){\n                    this.removeTagsFromValue(tagsToRemove.map(tag => tag.node))\n                    this.update() // update the original input with the current value\n\n                    if( _s.mode == 'select' && _s.userInput )\n                        this.setContentEditable(true);\n                }\n\n                // \"removeNode\" should be called AFTER \"removeTagsFromValue\" has been called,\n                // so the \"remove\" event is triggered after the tag is removed from the DOM\n                if( tranDuration && tranDuration > 10 && tagsToRemove.length == 1 )\n                    animation.call(this, tagsToRemove[0])\n                else\n                    tagsToRemove.forEach(removeNode.bind(this))\n            })\n            .catch(reason => {})\n    },\n\n    removeTagsFromDOM(){\n        this.getTagElms().forEach(node => node.remove())\n    },\n\n    /**\n     * @param {Array/Node} tags to be removed from the this.value array\n     */\n    removeTagsFromValue( tags ){\n        tags = Array.isArray(tags) ? tags : [tags];\n\n        tags.forEach(tag => {\n            var tagData = getSetTagData(tag),\n                tagIdx = this.getTagIdx(tagData)\n\n            //  delete tagData.__removed\n\n            if( tagIdx > -1 )\n                this.value.splice(tagIdx, 1)\n        })\n    },\n\n    removeAllTags( opts ){\n        opts = opts || {}\n        this.value = []\n\n        if( this.settings.mode == 'mix' )\n            this.DOM.input.innerHTML = ''\n        else\n            this.removeTagsFromDOM()\n\n        this.dropdown.refilter()\n        this.dropdown.position()\n\n        if( this.state.dropdown.visible )\n            setTimeout(() => {\n                this.DOM.input.focus()\n            })\n\n        if( this.settings.mode == 'select' ){\n            this.input.set.call(this)\n            this.settings.userInput && this.setContentEditable(true)\n        }\n\n        // technically for now only \"withoutChangeEvent\" exists in the opts.\n        // if more properties will be added later, only pass what's needed to \"update\"\n        this.update(opts, () => {\n            this.trigger('remove', {})\n        })\n\n    },\n\n    postUpdate(){\n        this.state.blockChangeEvent = false\n\n        var _s = this.settings,\n            classNames = _s.classNames,\n            hasValue = _s.mode == 'mix'\n                ? _s.mixMode.integrated\n                    ? this.DOM.input.textContent\n                    : this.DOM.originalInput.value.trim()\n                : this.value.length + this.input.raw.call(this).length;\n\n        this.toggleClass(classNames.hasMaxTags, this.value.length >= _s.maxTags)\n        this.toggleClass(classNames.hasNoTags, !this.value.length)\n        this.toggleClass(classNames.empty, !hasValue)\n\n        // specifically the \"select mode\" might have the \"invalid\" classname set when the field is changed, so it must be toggled on add/remove/edit\n        if( _s.mode == 'select' ){\n            this.toggleScopeValidation(this.value?.[0]?.__isValid)\n        }\n    },\n\n    setOriginalInputValue( v ){\n        var inputElm = this.DOM.originalInput;\n\n        if( !this.settings.mixMode.integrated ){\n            inputElm.value = v\n            inputElm.tagifyValue = inputElm.value // must set to \"inputElm.value\" and not again to \"inputValue\" because for some reason the browser changes the string afterwards a bit.\n        }\n    },\n\n    /**\n     * update the origianl (hidden) input field's value.\n     * uses a debounced timeout to prevent multiple rapid updates\n     * see - https://stackoverflow.com/q/50957841/104380\n     */\n    update( args, cb ){\n        clearTimeout(this.debouncedUpdateTimeout)\n        this.debouncedUpdateTimeout = setTimeout(reallyUpdate.bind(this), UPDATE_DELAY)\n        this.events.bindOriginaInputListener.call(this, UPDATE_DELAY)\n\n        var inputValue = this.getInputValue();\n        this.setOriginalInputValue(inputValue)\n\n        function reallyUpdate() {\n            this.setPersistedData(inputValue, 'value')\n\n            if( (!this.settings.onChangeAfterBlur || !(args||{}).withoutChangeEvent) && !this.state.blockChangeEvent )\n                this.triggerChangeEvent()\n\n            this.postUpdate()\n\n            cb?.()\n        }\n    },\n\n    getInputValue(){\n        var value = this.getCleanValue();\n\n        return this.settings.mode == 'mix'\n            ? this.getMixedTagsAsString(value)\n            : value.length\n                ? this.settings.originalInputValueFormat\n                    ? this.settings.originalInputValueFormat(value)\n                    : JSON.stringify(value)\n                : \"\"\n    },\n\n    /**\n     * removes properties from `this.value` which are only used internally\n     */\n    getCleanValue(v){\n        return removeCollectionProp(v || this.value, this.dataProps);\n    },\n\n    getMixedTagsAsString(){\n        var result = \"\",\n            that = this,\n            _s = this.settings,\n            originalInputValueFormat = _s.originalInputValueFormat || JSON.stringify,\n            _interpolator = _s.mixTagsInterpolator;\n\n        function iterateChildren(rootNode){\n            rootNode.childNodes.forEach((node) => {\n                if( node.nodeType == 1 ){\n                    const tagData = getSetTagData(node);\n\n                    if( node.tagName == 'BR'  ){\n                        result += \"\\r\\n\";\n                    }\n\n                    if( tagData && isNodeTag.call(that, node) ){\n                        if( tagData.__removed )\n                            return;\n                        else\n                            result += _interpolator[0] + originalInputValueFormat( omit(tagData, that.dataProps) ) + _interpolator[1]\n                    }\n                    else if( node.getAttribute('style') || ['B', 'I', 'U'].includes(node.tagName)  )\n                        result += node.textContent;\n\n                    else if( node.tagName == 'DIV' || node.tagName == 'P' ){\n                        result += \"\\r\\n\";\n                        //  if( !node.children.length && node.textContent )\n                        //  result += node.textContent;\n                        iterateChildren(node)\n                    }\n                }\n                else\n                    result += node.textContent;\n            })\n        }\n\n        iterateChildren(this.DOM.input)\n\n        return result;\n    }\n}\n\n// legacy support for changed methods names\nTagify.prototype.removeTag = Tagify.prototype.removeTags\n\nexport default Tagify\n", "import { extend, logger } from './helpers'\r\n\r\nexport default function EventDispatcher( instance ){\r\n    // Create a DOM EventTarget object\r\n    var target = document.createTextNode(''),\r\n        // keep track of all binded events & their callbacks to be able to completely remove all listeners of a speicific type\r\n        callbacksPerType = {}\r\n\r\n    function addRemove(op, events, cb){\r\n        if( cb )\r\n            events.split(/\\s+/g).forEach(ev => target[op + 'EventListener'].call(target, ev, cb))\r\n    }\r\n\r\n    // Pass EventTarget interface calls to DOM EventTarget object\r\n    return {\r\n        // unbinds all events\r\n        removeAllCustomListeners(){\r\n            Object.entries(callbacksPerType).forEach(([ev, cbArr]) => {\r\n                cbArr.forEach(cb => addRemove('remove', ev, cb))\r\n            })\r\n\r\n            callbacksPerType = {}\r\n        },\r\n\r\n        off(events, cb){\r\n            if( events ) {\r\n                if( cb )\r\n                    addRemove('remove', events, cb)\r\n                else\r\n                    // if `cb` argument was not specified then remove all listeners for the given event(s) types\r\n                    events.split(/\\s+/g).forEach(ev => {\r\n                        callbacksPerType[ev]?.forEach(cb => addRemove('remove', ev, cb))\r\n                        delete callbacksPerType[ev]\r\n                    })\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        on(events, cb){\r\n            if(cb && typeof cb == 'function') {\r\n                //track events callbacks to be able to remove them altogehter\r\n                events.split(/\\s+/g).forEach(ev => {\r\n                    if (Array.isArray(callbacksPerType[ev]) )\r\n                        callbacksPerType[ev].push(cb)\r\n                    else\r\n                        callbacksPerType[ev] = [cb]\r\n                })\r\n\r\n                addRemove('add', events, cb)\r\n            }\r\n\r\n            return this\r\n        },\r\n\r\n        trigger(eventName, data, opts){\r\n            var e;\r\n\r\n            opts = opts || {\r\n                cloneData:true\r\n            }\r\n\r\n            if( !eventName ) return;\r\n\r\n            if( instance.settings.isJQueryPlugin ){\r\n                if( eventName == 'remove' ) eventName = 'removeTag' // issue #222\r\n                jQuery(instance.DOM.originalInput).triggerHandler(eventName, [data])\r\n            }\r\n            else{\r\n                try {\r\n                    var eventData = typeof data === 'object'\r\n                        ? data\r\n                        : {value:data};\r\n\r\n                    eventData = opts.cloneData ? extend({}, eventData) : eventData\r\n                    eventData.tagify = this\r\n\r\n                    if( data.event )\r\n                        eventData.event = this.cloneEvent(data.event)\r\n\r\n                    // TODO: move the below to the \"extend\" function\r\n                    if( data instanceof Object )\r\n                        for( var prop in data )\r\n                            if(data[prop] instanceof HTMLElement)\r\n                                eventData[prop] = data[prop]\r\n\r\n                    e = new CustomEvent(eventName, {\"detail\":eventData})\r\n                }\r\n                catch(err){ logger.warn(err) }\r\n\r\n                target.dispatchEvent(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["ZERO_WIDTH_UNICODE_CHAR", "t", "e", "i", "n", "logger", "isEnabled", "window", "TAGIFY_DEBUG", "log", "_len", "arguments", "length", "args", "Array", "_key", "console", "this", "_to_consumable_array", "warn", "sameStr", "s1", "s2", "caseSensitive", "trim", "toLowerCase", "removeCollectionProp", "collection", "unwantedProps", "isArray", "map", "v", "omit", "obj", "props", "p", "newObj", "indexOf", "parseHTML", "s", "DOMParser", "parseFromString", "body", "firstElementChild", "getfirstTextNode", "elm", "action", "nodeType", "escapeHTML", "replace", "isObject", "type", "Object", "prototype", "toString", "call", "split", "slice", "extend", "o", "o1", "o2", "copy", "a", "b", "key", "hasOwnProperty", "assign", "concatWithoutDups", "newArr", "existingObj", "_iteratorNormalCompletion", "_didIteratorError", "_iteratorError", "undefined", "_step", "_iterator", "Symbol", "iterator", "arr", "value", "_iteratorNormalCompletion1", "_didIteratorError1", "_iteratorError1", "_step1", "_iterator1", "item", "push", "includes", "err", "return", "unaccent", "String", "normalize", "isChromeAndroidBrowser", "test", "navigator", "userAgent", "getUID", "c", "crypto", "getRandomValues", "Uint8Array", "isNodeTag", "node", "belongs", "isNodeBelongsToThisTagifyInstance", "isTag", "classList", "contains", "settings", "classNames", "tag", "isWithinNodeTag", "closest", "tagSelector", "namespaceSelector", "DOM", "scope", "injectAtCaret", "content", "range", "selection", "getSelection", "getRangeAt", "document", "createTextNode", "deleteContents", "insertNode", "getSetTagData", "tagElm", "data", "override", "__tagifyTagData", "placeCaretAfterNode", "parentNode", "nextSibling", "sel", "rangeCount", "setStartAfter", "collapse", "removeAllRanges", "addRange", "fixCaretBetweenTags", "tags", "TagifyHasFocuse", "forEach", "previousSibling", "textNode", "before", "DEFAULTS", "delimiters", "pattern", "tagTextProp", "maxTags", "Infinity", "callbacks", "addTagOnBlur", "addTagOn", "onChangeAfterBlur", "duplicates", "whitelist", "blacklist", "enforceWhitelist", "userInput", "focusable", "focusInputOnRemove", "keepInvalidTags", "createInvalidTags", "mixTagsAllowedAfter", "mixTagsInterpolator", "backspace", "skipInvalid", "pasteAsTags", "editTags", "clicks", "keepInvalid", "transformTag", "a11y", "focusableTags", "mixMode", "insertAfterTag", "autoComplete", "enabled", "rightKey", "tabKey", "namespace", "selectMode", "input", "focus", "tagNoAnimation", "tagInvalid", "tagNotAllowed", "scopeLoading", "hasMaxTags", "hasNoTags", "empty", "inputInvalid", "dropdown", "dropdownWrapper", "dropdownHeader", "dropdownFooter", "dropdownItem", "dropdownItemActive", "dropdownItemHidden", "dropdownItemSelected", "dropdownInital", "tagText", "tagX", "tagLoading", "tagEditing", "tagFlash", "tagHide", "classname", "maxItems", "searchKeys", "fuzzySearch", "accentedSearch", "includeSelectedTags", "highlightFirst", "closeOnSelect", "clearOnSelect", "position", "appendTarget", "hooks", "beforeRemoveTag", "Promise", "resolve", "beforePaste", "suggestionClick", "beforeKeyDown", "initDropdown", "_dropdown", "bind", "refs", "__tagify", "_object_spread_props", "suggestionsMethods", "events", "binding", "bindUnbind", "_CB", "_CBR", "listeners", "onKeyDown", "onMouseOver", "onMouseLeave", "onClick", "onScroll", "state", "hasFocus", "composing", "_s", "selectedElm", "querySelector", "dropdownItemActiveSelector", "selectedElmData", "getSuggestionDataByNode", "isMixMode", "mode", "isSelectMode", "tagify", "then", "result", "preventDefault", "dropdownItems", "_this", "getAllSuggestionsRefs", "actionUp", "getNextOrPrevOption", "matches", "dropdownItemSelector", "highlightOption", "itemsPerPage", "Math", "floor", "clientHeight", "offsetHeight", "isPageUp", "currentIndex", "targetIndex", "max", "min", "hide", "actions", "ArrowLeft", "shouldAutocompleteOnKey", "editing", "getMappedValue", "autoCompleteData", "autocomplete", "set", "selectOption", "setTimeout", "tagData", "suggestionElm", "nextOrPrevOption", "nextOrPrevOptionValue", "getAttribute", "getSuggestionNodeByValue", "addTags", "inputText", "catch", "raw", "charCodeAt", "removeTags", "editTag", "ddItem", "target", "button", "pos", "scrollTop", "scrollHeight", "trigger", "percentage", "round", "refilter", "query", "suggestedListItems", "filterListItems", "fill", "find", "selected", "next", "selectedIdx", "findIndex", "adjustScroll", "itemData", "className", "ddItemElm", "remove", "removeAttribute", "ddItemData", "suggest", "add", "setAttribute", "offsetTop", "event", "onSelect", "isNoMatch", "normalizedTagData", "normalizeTags", "onEditTagDone", "__isValid", "toggleFocusClass", "addEventListener", "fillHeaderFooter", "once", "selectAll", "onlyRendered", "tagsToAdd", "suggestions", "options", "whitelistItem", "valueIsInWhitelist", "searchBy", "isDuplicate", "niddle", "l", "startsWithMatch", "exactMatch", "_searchKeys", "keys", "some", "k", "_sd", "exact", "reduce", "values", "every", "q", "isTagDuplicate", "exactMatchesList", "sortby", "list", "unshift", "d", "suggestionsCount", "hasCustomSort", "filter", "_this1", "filteredList", "concat", "mapValueTo", "createListHTML", "sugegstionsList", "suggestion", "idx", "mappedValue", "templates", "apply", "join", "parseTemplate", "getHeaderRef", "getFooterRef", "querySelectorAll", "show", "firstListItem", "firstListItemValue", "noMatchListItem", "allowNewTags", "noWhitelist", "isManual", "dropdownItemNoMatch", "isLoading", "readonly", "clearTimeout", "dropdownHide__bindEventsTimeout", "visible", "setStateSelection", "render", "overrideManual", "_this_DOM", "removeEventListener", "removeChild", "flaggedTags", "baseOffset", "toggle", "getAppendTarget", "height", "clone", "ddHeight", "cloneNode", "style", "cssText", "appendChild", "HTMLContent", "dropdownContent", "innerHTML", "newHeaderElem", "newFooterElem", "headerRef", "footerRef", "replaceChild", "rect", "top", "bottom", "left", "width", "ancestorsOffsets", "isPlacedAbove", "hasSpaceOnRight", "cssTop", "cssLeft", "ddElm", "isRTL", "RTL", "isDefaultAppendTarget", "isSelfAppended", "appendTargetScrollTop", "pageYOffset", "root", "fullscreenElement", "webkitFullscreenElement", "documentElement", "viewportHeight", "viewportWidth", "clientWidth", "innerWidth", "positionTo", "ddTarget", "r2", "r", "startContainer", "offset", "startOffset", "createRange", "setStart", "setEnd", "getBoundingClientRect", "right", "getCaretGlobalPosition", "offsetLeft", "accumulatedAncestorsScrollTop", "getAccumulatedAncestorsScrollTop", "ceil", "placeAbove", "pageXOffset", "STORE_KEY", "TEXTS", "exceed", "duplicate", "notAllowed", "wrapper", "disabled", "required", "placeholder", "param", "title", "class", "getAttributes", "_t", "hasMore", "customBinding", "customEventsList", "name", "on", "mainEvents", "eventName", "main", "bindGlobal", "isJQueryPlugin", "jQuery", "originalInput", "removeAllTags", "keydown", "onKeydown", "click", "onClickScope", "dblclick", "onDoubleClickScope", "paste", "onPaste", "drop", "onDrop", "compositionstart", "onCompositionStart", "compositionend", "onCompositionEnd", "inputMutationObserver", "MutationObserver", "onInputDOMChange", "disconnect", "observe", "childList", "bindOriginaInputListener", "delay", "DELAY", "clearInterval", "originalInputValueObserverInterval", "setInterval", "observeOriginalInputValue", "unbind", "global", "isIE", "cb", "onWindowKeyDown", "onFocusBlur", "onClickAnywhere", "useCapture", "unbindGlobal", "_this_value_", "_this_value", "nodeTag", "relatedTarget", "targetIsTagNode", "isTargetXBtn", "isFocused", "lostFocus", "Date", "text", "textContent", "currentDisplayValue", "ddEnabled", "eventData", "isTargetSelectOption", "isTargetAddNewBtn", "addNew", "postUpdate", "triggerChangeEvent", "dropdownCanBeShown", "tagTextSelector", "setRangeAtStartEnd", "loading", "firstTagNode", "getTagElms", "nextTag", "focusedElm", "activeElement", "isBelong", "isInputNode", "isReadyOnlyTag", "hasAttribute", "isDropdownVisible", "nextElementSibling", "targetIsRemoveBtn", "deleteKeyTagDetected", "anchorOffset", "anchorNode", "prevAnchorSibling", "isCaretAfterTag", "el", "createElement", "enc", "innerText", "lastTagElems", "tagBeforeCaret", "tagElmToBeDeleted", "firstTextNodeBeforeTag", "isZWS", "nodeValue", "fromCharCode", "previousElementSibling", "_instanceof", "Element", "nodeName", "collapseToEnd", "isManualDropdown", "blur", "inputSuggestion", "thingToAdd", "onInput", "onMixTagsInput", "showSuggestions", "inputElm", "validation", "validateTag", "toggleScopeValidation", "isValid", "search", "rangeText", "match", "matchedPatternCount", "matchFlaggedTag", "matchDelimiters", "lastTagsCount", "tagsElems", "fragment", "createDocumentFragment", "remainingTagsValues", "inputType", "createTagElem", "childNodes", "lastChild", "update", "withoutChangeEvent", "cloneRange", "focusNode", "endOffset", "lastIndexOf", "prefix", "onInputIE", "destroy", "tagifyValue", "loadOriginalValues", "closestTagifyDropdownElem", "dropdownSelector", "timeDiffFocus", "index", "getNodeIndex", "fixFirefoxLastTagNoCaret", "clipboardData", "pastedText", "getData", "onEditTagInput", "editableElm", "_obj", "tagElmIdx", "textValue", "dataForChangedProp", "_define_property", "__tagId", "editTagChangeDetected", "originalIsValid", "newValue", "onEditTagPaste", "newNode", "onEditTagClick", "onEditTagFocus", "onEditTagBlur", "isRelatedTargetNodeTag", "newTagData", "originalData", "__originalData", "hasChanged", "_obj1", "message", "onEditTagkeydown", "__originalHTML", "EDITED_TAG_BLUR_DELAY", "isEditingTag", "editable", "m", "record", "addedNodes", "addedNode", "outerHTML", "replaceWith", "newlineText", "nextNode", "anythingAfterNode", "removedNodes", "removedNode", "lastInputChild", "Tagify", "mockInstance", "Proxy", "get", "id", "instance", "callbacksPerType", "addRemove", "op", "ev", "removeAllCustomListeners", "entries", "cbArr", "off", "opts", "cloneData", "triggerHandler", "cloneEvent", "prop", "HTMLElement", "CustomEvent", "detail", "dispatchEvent", "isFirefox", "documentMode", "getPersistedData", "localStorage", "persistedData", "customKey", "getItem", "JSON", "parse", "setPersistedData", "setItem", "stringify", "Event", "clearPersistedData", "base", "removeItem", "applySettings", "build", "getCSSVars", "autofocus", "helpers", "dataProps", "template", "setContentEditable", "generateClassSelectors", "currentName", "defineProperty", "mergedDefaults", "attrVal", "RegExp", "_delimiters", "_object_spread", "texts", "persistedWhitelist", "attrs", "getCustomAttributes", "propName", "output", "compStyle", "getComputedStyle", "CSSVars", "tagHideTransition", "unit", "pop", "getPropertyValue", "labelWrapper", "integrated", "originalInput_tabIndex", "tabIndex", "inputSelector", "insertBefore", "_this_DOM_scope_parentNode", "_this_listeners_main", "_this_listeners", "blockChangeEvent", "persistedOriginalValue", "parseMixTags", "tagName", "insertAdjacentHTML", "lastOriginalValueReported", "clonedEvent", "toggleClass", "force", "setPlaceholder", "str", "changed", "bubbles", "simulated", "_valueTracker", "setValue", "random", "start", "getTagTextNode", "setTagTextNode", "HTML", "getLastTag", "tagIdx", "skipValidation", "editTagToggleValidity", "removeTagsFromValue", "previousData", "replaceTag", "reCheckInvalidTags", "getInvalidTagAttrs", "newTagElm", "updateValueByDOMTags", "clsNames", "skipNodesWithClassNames", "cls", "injectedNode", "_this_state_selection", "appendMixTags", "updateDOM", "hideDropdown", "validate", "source", "charAt", "suggestedText", "suggestionStart", "substr", "suggestionTrimmed", "substring", "dataSuggest", "replaceTextWithNode", "getTagIdx", "classess", "_sc", "tagNodes", "tagId", "dupsCount", "done", "getTagIndexByValue", "indices", "isCaseSensitive", "getTagElmByValue", "flashTag", "isTagBlacklisted", "x", "isTagWhitelisted", "getWhitelistItem", "_wi", "_wiv", "setReadonly", "attrribute", "contentEditable", "setDisabled", "isDisabled", "tagsItems", "_this_settings", "whitelistMatches", "whitelistWithProps", "isCollection", "mapStringToCollection", "acc", "trimmed", "itemCopy", "whitelistMatchesValues", "filteredItem", "matchObj", "tagsDataSet", "textProp", "preInterpolated", "maxTagsReached", "Error", "newWrapperNode", "strToReplace", "nodeToReplace", "nodeAtCaret", "firstSplitOffset", "splitText", "prepareNewTagNode", "aggregatedInvalidInput", "tagElmParams", "__preInvalidData", "postProcessNewTagNode", "selectTag", "lastTagElm", "appendTag", "addEmptyTag", "initialData", "clearInput", "tagElems", "frag", "addedTags", "addMixTags", "newTagNode", "tagsData", "prefixedTextToTag", "children", "_this_state_tag", "newTag", "createdFromDelimiters", "insertBeforeNode", "extraData", "templateData", "textnode", "iter", "createNodeIterator", "NodeFilter", "SHOW_TEXT", "tagValidation", "tagElms", "silent", "tranDuration", "tagsToRemove", "elms", "__removed", "removeNode", "parseFloat", "clientTop", "reason", "removeTagsFromDOM", "splice", "hasValue", "setOriginalInputValue", "debouncedUpdateTimeout", "inputValue", "getInputValue", "getCleanValue", "getMixedTagsAsString", "originalInputValueFormat", "that", "_interpolator", "iterateChildren", "rootNode", "removeTag"]
}
